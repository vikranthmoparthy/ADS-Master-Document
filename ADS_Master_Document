"""
File Name: ADS_Master_Document.py
Details: Contains all assignment and tutorial code, as well as data structure code, time complexity information and additional functionality
"""

"""
General Data Structures
"""

"""
Stacks
"""

class Stack:
    """
    Creates a stack that allows for last-in-first-out (LIFO) access
    """

    def __init__(self):
        self._stack = []

    def push(self, item) -> None:
        """
        Adds an item to the top of the stack
        :param item: item to add
        """
        self._stack.append(item)

    def pop(self):
        """
        Removes and returns the item on top of the stack
        :return: item on top of the stack
        """
        return self._stack.pop()

    def size(self) -> int:
        """
        Returns the number of items on the stack
        :return: number of items on the stack
        """
        return len(self._stack)
    
    def to_list(self):
        """
        Returns a list of all items in the stack from bottom to top.
        :return: list of items in LIFO order (bottom to top)
        """
        return self._stack[:]

# Time Complexity Analysis for Stack Class:

# push(item): O(1)
# Appends an item to the end of the list. In Python, appending to a list is an O(1) operation in the average case.

# pop(): O(1)
# Removes and returns the last item from the list. Popping from the end of a list is an O(1) operation in Python.

# size(): O(1)
# Returns the length of the list using len(). The len() function in Python is an O(1) operation as it directly accesses the stored size of the list.

# to_list(): O(n)
# Returns a shallow copy of the list using slicing. Slicing a list has a time complexity of O(n), where n is the number of elements in the list.

"""
Queues
"""

class Queue:
    """
    Creates a first-in-first-out (FIFO) queue
    """

    def __init__(self):
        self._q = [0, 0]
        self._front = 0
        self._back = 0

    def size(self) -> int:
        """
        Returns the number of items in the queue
        :return: number of items in the queue
        """
        size = self._back - self._front
        if self._front > self._back:
            size += len(self._q)
        return size

    def dequeue(self):
        """
        Removed and returns the oldest item in the queue
        :return: the item that has been in the queue the longest
        """
        if self.size() == 0:
            print("Queue empty!")
            return None
        item = self._q[self._front]
        self._front = (self._front + 1) % len(self._q)
        return item

    def enqueue(self, item) -> None:
        """
        Adds an item to the end of the queue
        :param item: item to add to the queue
        """
        self._q[self._back] = item
        self._back = (self._back + 1) % len(self._q)
        if self._back == self._front:
            self._back += len(self._q)
            self._q.extend(self._q)
    
    def to_list(self):
        """
        Returns a list of all items in the queue in order.
        :return: list of items in FIFO order
        """
        if self.size() == 0:
            return []
        
        if self._front < self._back:
            return self._q[self._front:self._back]
        else:
            return self._q[self._front:] + self._q[:self._back]

# Time Complexity Analysis for Queue Class:

# __init__(): O(1)
# Initializes the queue with a fixed-size list and sets the front and back pointers.

# size(): O(1)
# Calculates the size of the queue using simple arithmetic operations.

# dequeue(): O(1)
# Removes and returns the front item from the queue. Uses modulo arithmetic for circular queue implementation.

# enqueue(item): O(1) amortized, O(n) worst case
# Adds an item to the end of the queue. Amortized O(1) because extending the list is infrequent, but when it does occur, it takes O(n) time, where n is the current size of the queue.

# to_list(): O(n)
# Returns a list of all items in the queue by iterating through the circular buffer.

"""
LinkedList
"""

class LinkedList:
    """
    Creates a linked list data structure
    """
    def __init__(self, item = None, next = None):
        self._item = item
        self._next = next

    def _list_empty_error(self) -> None:
        print("List empty")


    def get_first_item(self):
        """
        Returns the first value stored in the linked list
        :return: the first value stored in the linked list
        """
        if self._next is None:
            self._list_empty_error()
            return None
        return self._next._item

    def remove_first_item(self):
        """
        Returns and removes the first value stored in the linked list
        :return: the first value stored in the linked list
        """
        if self._next is None:
            self._list_empty_error()
            return None
        item = self._next._item
        self._next = self._next._next
        return item

    def size(self) -> int:
        """
        Returns the number of items stored in the linked list
        :return: the number of items stored in the linked list
        """
        size = 0
        node = self._next
        while node is not None:
            size += 1
            node = node._next
        return size

    def visit(self, action) -> None:
        """
        Performs an action for every item stored on the list
        :param action: function that takes the value of a node as input
        """
        if self._next is not None:
            action(self._next._item)
            self._next.visit(action)

    def _invalid_position(self) -> None:
        print("Invalid position")

    def _list_too_short_error(self) -> None:
        print("Linked list is too short")

    def get_item(self, pos: int):
        """
        Returns the item at the given position in the linked list
        :param pos: position of the item to return
        :return: the item at the given position in the linked list
        """
        if pos < 0:
            self._invalid_position()
            return None
        if self._next is None:
            self._list_too_short_error()
            return None
        if pos == 0:
            return self._next._item
        return self._next.get_item(pos - 1)

    def add(self, item, pos: int = 0) -> None:
        """
        Adds an item to the linked list
        :param item: item to add
        :param pos: position to add the item (by default at the start of the linked list)
        """
        if pos < 0:
            self._invalid_position()
        elif pos == 0:
            self._next = LinkedList(item, self._next)
        elif self._next is not None:
            self._next.add(item, pos - 1)
        else:
            self._list_too_short_error()

    def _value_not_found_error(self):
        print("Value not found")

    def remove(self, value) -> None:
        """
        Removes the first occurrence of a given value
        :param value: value to remove
        """
        if self._next is not None:
            if self._next._item == value:
                self.remove_first_item()
            else:
                self._next.remove(value)
        else:
            self._value_not_found_error()

    def remove_iterative(self, value) -> None:
        node = self
        while node._next is not None and node._next._item != value:
            node = node._next
        if node._next is not None:
            node._next = node._next._next
        else:
            self._value_not_found_error()

# Time Complexity Analysis for LinkedList Class:

# __init__(item=None, next=None): O(1)
# Initializes a new node with given item and next pointer.

# _list_empty_error(): O(1)
# Prints an error message.

# get_first_item(): O(1)
# Returns the first item in the list (if it exists).

# remove_first_item(): O(1)
# Removes the first item in the list (if it exists).

# size(): O(n)
# Iterates through the list to count the number of items.

# visit(action): O(n)
# Recursively applies the given action to each item in the list.

# _invalid_position(): O(1)
# Prints an error message.

# _list_too_short_error(): O(1)
# Prints an error message.

# get_item(pos): O(n)
# Recursively traverses the list to find the item at the given position.

# add(item, pos=0): O(n)
# Recursively traverses the list to add the item at the given position.

# _value_not_found_error(): O(1)
# Prints an error message.

# remove(value): O(n)
# Recursively traverses the list to remove the first occurrence of the given value.

# remove_iterative(value): O(n)
# Iteratively traverses the list to remove the first occurrence of the given value.

"""
Trees
"""

class TreeNode:

    def __init__(self, item=None, left=None, right=None):
        self._item = item
        self._height = 0
        self._left = left
        self._right = right

    def _update_height(self) -> None:
        self._height = 0
        if self._left is not None:
            self._height = max(self._height, self._left._height + 1)
        if self._right is not None:
            self._height = max(self._height, self._right._height + 1)

    
    def _get_height_imbalance(self) -> int:
        imbalance = 0
        if self._left is not None:
            imbalance -= self._left._height
        if self._right is not None:
            imbalance += self._right._height
        return imbalance

    #Traversals
    def preorder(self, action):
        action(self._item)
        if self._left is not None:
            self._left.preorder(action)
        if self._right is not None:
            self._right.preorder(action)

    def postorder(self, action):
        if self._left is not None:
            self._left.postorder(action)
        if self._right is not None:
            self._right.postorder(action)
        action(self._item)

    def inorder(self, action):
        if self._left is not None:
            self._left.inorder(action)
        action(self._item)
        if self._right is not None:
            self._right.inorder(action)

# Time Complexity Analysis for TreeNode Class:

# __init__(item=None, left=None, right=None): O(1)
# Initializes a new node with given item, height, and child pointers.

# _update_height(): O(1)
# Updates the height of the current node based on the heights of its children.

# _get_height_imbalance(): O(1)
# Calculates the height imbalance of the current node based on the heights of its children.

# preorder(action): O(n)
# Recursively applies the given action to each node in a preorder traversal.

# postorder(action): O(n)
# Recursively applies the given action to each node in a postorder traversal.

# inorder(action): O(n)
# Recursively applies the given action to each node in an inorder traversal.


#Search for a value in tree       
def search_in_search_tree(tree: TreeNode, value):
    if tree is None:
        return tree
    if value == tree._item:
        return tree
    if value < tree._item:
        return search_in_search_tree(tree._left, value)
    return search_in_search_tree(tree._right, value)

#Add to a search tree
def add_in_search_tree(tree: TreeNode, value) -> TreeNode:
    if tree is None:
        return TreeNode(value)
    if value < tree._item:
        tree._left = add_in_search_tree(tree._left, value)
        tree._update_height()
    elif value > tree._item:
        tree._right = add_in_search_tree(tree._right, value)
        tree._update_height()
    return tree

def _rotate_clockwise(tree: TreeNode) -> TreeNode:
    new_root = tree._left
    tree._left = new_root._right
    new_root._right = tree
    tree._update_height()
    new_root._update_height()
    return new_root

def _rotate_anticlockwise(tree: TreeNode) -> TreeNode:
    new_root = tree._right
    tree._right = new_root._left
    new_root._left = tree
    tree._update_height()
    new_root._update_height()
    return new_root

def _rebalance_tree(tree: TreeNode) -> TreeNode:
    imbalance = tree._get_height_imbalance()
    if imbalance <= -2:
        if tree._left._get_height_imbalance() <= 0:
            return _rotate_clockwise(tree)
        else:
            tree._left = _rotate_anticlockwise(tree._left)
            return _rotate_clockwise(tree)
    elif imbalance >= 2:
        if tree._right._get_height_imbalance() >= 0:
            return _rotate_anticlockwise(tree)
        else:
            tree._right = _rotate_clockwise(tree._right)
            return _rotate_anticlockwise(tree)
    return tree

# Time Complexity Analysis for Search Tree Functions:

# search_in_search_tree(tree, value):
# O(h) - where h is the height of the tree. In a balanced tree, h is log(n),
# but in the worst case (e.g., skewed tree), it can be O(n).

# add_in_search_tree(tree, value):
# O(h) - where h is the height of the tree for the same reasons as above.
# Includes an O(1) call to _update_height().

# _rotate_clockwise(tree):
# O(1) - Simple pointer manipulations. Includes two O(1) calls to _update_height().

# _rotate_anticlockwise(tree):
# O(1) - Simple pointer manipulations. Includes two O(1) calls to _update_height().

# _rebalance_tree(tree):
# O(1) - Simple height checks and calls to rotate, which are O(1).


"""
Heaps
"""

class Heap:
    def __init__(self):
        self._heap = [0]

    def size(self) -> int:
        return len(self._heap) - 1

    def _heap_empty_error(self) -> None:
        print("Heap empty")

    def _upheap(self, index: int) -> None:
        if index == 1:  
            return
        parent_index = index // 2  # Parent node index
        if self._heap[parent_index] < self._heap[index]:  # Max heap condition
            self._heap[index], self._heap[parent_index] = self._heap[parent_index], self._heap[index]
            self._upheap(parent_index)

    def enqueue(self, value) -> None:
        self._heap.append(value)
        self._upheap(len(self._heap) - 1)

    def _downheap(self, index: int) -> None:
        left = 2 * index
        right = (2 * index) + 1
        v = self._heap[index]

        if left < len(self._heap):
            lc = self._heap[left]
        else:
            lc = None

        if right < len(self._heap):
            rc = self._heap[right]
        else:
            rc = None

        if lc is not None or rc is not None:
            if lc is not None and rc is not None:
                if lc >= rc and lc > v:
                    self._heap[left], self._heap[index] = self._heap[index], self._heap[left]
                    self._downheap(left)
                elif rc > v:
                    self._heap[right], self._heap[index] = self._heap[index], self._heap[right]
                    self._downheap(right)

            elif lc is not None and lc > v:
                self._heap[left], self._heap[index] = self._heap[index], self._heap[left]
                self._downheap(left)

            elif rc is not None and rc > v:
                self._heap[right], self._heap[index] = self._heap[index], self._heap[right]
                self._downheap(right)

    def remove_max(self):
        if self.size() == 0:
            self._heap_empty_error()
            return None
        if self.size() == 1:
            return self._heap.pop()
        
        return_value = self._heap[1]
        self._heap[1] = self._heap.pop()
        self._downheap(1)
        return return_value

    def remove_min(self):
        if self.size() == 0:
            self._heap_empty_error()
            return None
        if self.size() == 1:
            return self._heap.pop()

        min_index = 1  # Start from the first element (root)
        for i in range(2, len(self._heap)):  # Find the minimum in the heap
            if self._heap[i] < self._heap[min_index]:
                min_index = i

        return_value = self._heap[min_index]
        self._heap[min_index] = self._heap.pop()  # Replace with the last element

        if min_index < len(self._heap):  
            self._downheap(min_index)  # Restore heap property if needed

        return return_value

# Time Complexity Analysis for Heap Class:

# __init__(): O(1)
# Initializes the heap with an initial list containing a placeholder element.

# size(): O(1)
# Returns the number of elements in the heap (excluding the placeholder).

# _heap_empty_error(): O(1)
# Prints an error message if the heap is empty.

# _upheap(index): O(log n)
# Moves an element up the heap to maintain heap property.

# enqueue(value): O(log n)
# Adds a new element to the end of the heap and then calls _upheap to maintain heap property.

# _downheap(index): O(log n)
# Moves an element down the heap to maintain heap property.

# remove_max(): O(log n)
# Removes the maximum element from the heap (root) and then calls _downheap to maintain heap property.

# remove_min(): O(n)
# Removes the minimum element from the heap. Needs to iterate through all elements and then calls _downheap.


"""
GraphEdge
"""

class GraphEdge:
    def __init__(self, origin, destination, weight: float = 1.0):
        self._origin = origin
        self._destination = destination
        self._weight = weight

    def is_incident(self, node: int) -> bool:
        return node == self._origin or node == self._destination

    def other_node(self, node: int) -> int:
        if self.is_incident(node):
            return self._origin + self._destination - node
        return -1

    def get_weight(self) -> float:
        return self._weight

# Time Complexity Analysis for GraphEdge Class:

# __init__(origin, destination, weight=1.0): O(1)
# Initializes a new edge with the given origin, destination, and weight.

# is_incident(node): O(1)
# Checks if the given node is incident to the edge.

# other_node(node): O(1)
# Returns the other node connected by the edge.

# get_weight(): O(1)
# Returns the weight of the edge.

"""
UndirectedGraph - List Representation
"""

class UndirectedGraph:
    def __init__(self, node_count: int):
        self._neighbours = [[] for _ in range(node_count)]

    def add_edge(self, node1: int, node2: int, weight: int = 1):
        new_edge = GraphEdge(node1, node2, weight)
        self._neighbours[node1].append(new_edge)
        self._neighbours[node2].append(new_edge)

# Time Complexity Analysis for UndirectedGraph Class (List Representation):

# __init__(node_count): O(n)
# Initializes the graph with a list of empty lists (adjacency lists) for each node.

# add_edge(node1, node2, weight=1): O(1)
# Adds an edge between node1 and node2.


"""
UndirectedGraph - Matrix Representation
"""

class UndirectedGraph:
    def __init__(self, node_count: int):
        self._edges = [[None] * node_count for _ in range(node_count)]

    def add_edge(self, node1: int, node2: int, weight: int = 1):
        self._edges[node1][node2] = weight
        self._edges[node2][node1] = weight

# Time Complexity Analysis for UndirectedGraph (Matrix Representation) Class:

# __init__(node_count): O(n^2)
# Initializes the graph with a matrix of size n x n (n = node_count).

# add_edge(node1, node2, weight=1): O(1)
# Adds an edge between node1 and node2 by updating two positions in the matrix.


#Depth-first search
def depth_first_search(self, start_node: int, action, visited: list[bool] = None) -> list[bool]:
    if visited is None:
        visited = [False] * len(self._neighbours)
    action(start_node)
    visited[start_node] = True
    for edge in self._neighbours[start_node]:
        other_node = edge.other_node(start_node)
        if not visited[other_node]:
            self.depth_first_search(other_node, action, visited)
    return visited

#Breadth-first search
def breadth_first_search(self, start_node, action) -> list[bool]:
    visited = [False] * len(self._neighbours)
    q = Queue()
    visited[start_node] = True
    q.enqueue(start_node)
    while q.size() > 0:
        current_node = q.dequeue()
        action(current_node)
        for edge in self._neighbours[current_node]:
            other_node = edge.other_node(current_node)
            if not visited[other_node]:
                visited[other_node] = True
                q.enqueue(other_node)
    return visited

# Time Complexity Analysis for Graph Traversal Functions:

# depth_first_search(self, start_node, action, visited=None):
# O(V + E) - where V is the number of vertices (nodes) and E is the number of edges in the graph.

# breadth_first_search(self, start_node, action):
# O(V + E) - where V is the number of vertices (nodes) and E is the number of edges in the graph.

"""
Lab Assignment Code
"""

"""
lab1planes
"""

import sys
#from queue import Queue
#from stack import Stack

RUNWAY_LENGTH = 7
HANGAR_SIZE = 5
lines = sys.stdin.read().splitlines()
lines.pop() 
exit = Queue()
waiting_runway = Queue() #Waiting_runway is a queue because it is FIFO (first-in-first-out)
hangar = Stack() #Hangar is a stack because it is LIFO (last-in-first-out)

for line in lines:
    airplane, condition = line.strip().split("\t")
    if condition == "yes":
        hangar.push(airplane)
        #If the hangar is now full, clear runway and add all planes in hangar to the runway
        if hangar.size() == 5:
            while waiting_runway.size() != 0:
                exit.enqueue(waiting_runway.dequeue())
            while hangar.size() != 0:
                waiting_runway.enqueue(hangar.pop())
    elif condition == "no":
        waiting_runway.enqueue(airplane)
        #If the waiting is now full, clear it.
        if waiting_runway.size() == 7:
            while waiting_runway.size() != 0:
                exit.enqueue(waiting_runway.dequeue())

#After processing all planes, we now send planes to exit. First we send the planes from the runway, then from the hangar (because of the diagram).
while waiting_runway.size() != 0:
    exit.enqueue(waiting_runway.dequeue())
while hangar.size() != 0:
    exit.enqueue(hangar.pop())

#Print the order in which the planes exit.
while exit.size() != 0:
    print(exit.dequeue())

# Time Complexity Analysis for lab1planes.py:

# Overall Time Complexity: O(n)
# Explanation: The main loop iterates through each line in the input,
# and the operations inside the loop (enqueue, push, pop, size) are O(1)
# for the data structures used (Queue and Stack).
# The while loops after processing the lines also have O(n) complexity in total.

"""
lab2equations
"""

"""
Scanner
"""

from enum import Enum

class TokenType(Enum):
    """
    Tokens can be of three types:
    numbers (digits), identifiers (characters), and symbols (any)
    """
    NUMBER = 1
    IDENTIFIER = 2
    SYMBOL = 3


class TokenList:
    def __init__(self):
        self._type = TokenType.NUMBER
        self._value = None
        self._next = None

    def __str__(self): 
        return_value = "NUMBER" if self._type == TokenType.NUMBER else \
                        "IDENTIFIER" if self._type == TokenType.IDENTIFIER else \
                        "SYMBOl"
        if self._next is not None:
            return_value += " " + str(self._next)
        return return_value


def _match_number(text: str, position: int) -> tuple[int, int]:
    """
    Reads a number from the input
    :param text: input string
    :param position: start position of the number
    :return: (number read, first position in text after the read number)
    """
    output = 0
    while position < len(text) and "0" <= text[position] <= "9":
        output = output*10 + int(text[position])
        position += 1
    return output, position


def _match_symbol(text: str, position: int) -> tuple[str, int]:
    """
    Reads a single character as a symbol from the input
    :param text: input string
    :param position: start position of the symbol
    :return: (symbol read, first position in text after the read symbol)
    """
    return text[position], position + 1


def _match_identifier(text: str, position: int) -> tuple[str, int]:
    """
    Reads an identifier  from the input
    :param text: input string
    :param position: start position of the identifier
    :return: (identifier read, first position in text after the read identifier)
    """
    old_position = position
    while position < len(text) and text[position].isalnum():
        position += 1
    return text[old_position:position], position


def _generate_node(text: str, position: int) -> tuple[TokenList, int]:
    """
    Generates a new TokenList node.
    :param text: string to read the node information from
    :param position: start position of the information
    :return: a tuple with the generated node and the new position in the input
    """
    new_node = TokenList()
    if "0" <= text[position] <= "9":
        # A digit signals the start of a number
        new_node._type = TokenType.NUMBER
        new_node._value, position = _match_number(text, position)
    elif text[position].isalpha():
        # An alphabetic character signals an identifier
        new_node._type = TokenType.IDENTIFIER
        new_node._value, position = _match_identifier(text, position)
    else:
        # In all other cases, it is a symbol
        new_node._type = TokenType.SYMBOL
        new_node._value, position = _match_symbol(text, position)
    return new_node, position


def generate_token_list(text: str) -> TokenList:
    head = None
    tail = None
    position = 0
    while position < len(text):
        if text[position].isspace():
            position += 1
        else:
            node, position = _generate_node(text, position)
            if head is None:
                head = node
            else:
                tail._next = node
            tail = node
    return head

"""
Lab Code
"""

#from scanner import *

class TokenListPosition:
    def __init__(self, tokens: TokenList):
        self.tokens = tokens

def accept_number(position: TokenListPosition) -> bool:
    if position.tokens is not None:
        if position.tokens._type == TokenType.NUMBER:
            position.tokens = position.tokens._next
            return True
    return False

def accept_identifier(position: TokenListPosition) -> bool:
    if position.tokens is not None:
        if position.tokens._type == TokenType.IDENTIFIER:
            position.tokens = position.tokens._next
            return True
    return False

def accept_symbol(position: TokenListPosition, symbol: str) -> bool:
    if position.tokens is not None:
        if position.tokens._type == TokenType.SYMBOL:
            if position.tokens._value == symbol:
                position.tokens = position.tokens._next
                return True
    return False

def accept_factor(position: TokenListPosition) -> bool:
    return (
        accept_number(position) or
        accept_identifier(position) or
        (accept_symbol(position, "(") and 
        accept_expression(position) and 
        accept_symbol(position, ")")))

def accept_term(pos: TokenListPosition) -> bool:
    encountered_number = accept_number(pos)

    encountered_identifier = accept_identifier(pos)

    if not (encountered_number or encountered_identifier):
        return False
    elif encountered_number and not encountered_identifier:
        return True
    
    encountered_carrot = accept_symbol(pos, "^")
    if encountered_carrot:
        if not accept_number(pos):
            return False
    return True

def accept_expression(pos: TokenListPosition) -> bool:
    # Optional '-' at the beginning
    if accept_symbol(pos, "-"):
        pass

    # Must have at least one term
    if not accept_term(pos):
        return False

    # Zero or more occurrences of '+' or '-' followed by a term
    while accept_symbol(pos, "+") or accept_symbol(pos, "-"):
        if not accept_term(pos):
            return False

    return True


def recognize_equation(tokenlist: TokenList) -> bool:
    """
    Determines whether a token list represents a valid equation.
    
    :param tokenlist: input token list
    :return: True if the token list represents a valid equation, otherwise False.
    """
    pos = TokenListPosition(tokenlist)
    
    # Check for the first expression
    if not accept_expression(pos):
        return False
    
    # Check for the '=' symbol
    if not accept_symbol(pos, "="):
        return False
    
    # Check for the second expression after the '=' symbol
    if not accept_expression(pos):
        return False
    
    if not pos.tokens is None:
        return False
    
    return True


def get_degree(tokenlist: TokenList) -> int:
    """
    Determines the highest exponent in a token list.
    For linear terms, the exponentiation symbol is optional, and the exponent is considered 1.

    :param tokenlist: input token list
    :return: the highest exponent in the token list, or 0 if no exponent is found
    """
    current_token = tokenlist
    max_exponent = 0  # Default to 0 if no exponent is found

    while current_token is not None:
        if current_token._type == TokenType.SYMBOL and current_token._value == "^":
            # Check if the next token is a number (exponent)
            next_token = current_token._next
            if next_token is not None and next_token._type == TokenType.NUMBER:
                max_exponent = max(max_exponent, int(next_token._value))
        elif current_token._type == TokenType.IDENTIFIER:
            # For identifiers (e.g., x), assume an exponent of 1 if no ^ is found
            if current_token._next is None or current_token._next._type != TokenType.SYMBOL or current_token._next._value != "^":
                max_exponent = max(max_exponent, 1)
        current_token = current_token._next

    return max_exponent


def is_single_variable_equation(tokenlist: TokenList) -> bool:
    """
    Determines whether a token list contains exactly one distinct identifier.

    :param tokenlist: input token list
    :return: True iff the token list contains exactly one distinct identifier.
    """
    current_token = tokenlist
    identifiers = set()  # Set to store distinct identifiers

    while current_token is not None:
        if current_token._type == TokenType.IDENTIFIER:
            identifiers.add(current_token._value)
        current_token = current_token._next

    return len(identifiers) == 1

Time Complexity Analysis Summary:

Scanner:
    _match_number: O(k) (k = digits in number)
    _match_symbol: O(1)
    _match_identifier: O(k) (k = chars in identifier)
    generate_token_list: O(n) (n = input text length)

Parser:
    accept_term, accept_number, accept_identifier, accept_symbol: O(1)
    accept_expression: O(n) (n = tokens in expression)
    recognize_equation: O(n) (n = tokens in equation)
    get_degree: O(n) (n = tokens in equation)
    is_single_variable_equation: O(n) (n = tokens in equation)

Overall: O(n) where n is the length of the input string (due to parsing).


"""
lab3spellchecker: efficient solution
"""

class TrieNode:
    def __init__(self): #Using definition given in question
        self._children: dict[str, TrieNode] = {} 
        self.is_end_of_word = False #Keeping track of end of trie branch

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def add(self, word):
        current_node = self.root
        for char in word:
            if char not in current_node._children: #Checking if character already exists as a node
                current_node._children[char] = TrieNode() #If not, create
            current_node = current_node._children[char]
        current_node.is_end_of_word = True
    
    def search_in_trie(self, p): #Using the pseudocode from Prof. de Weerd's slides 
        t = self.root
        for x in p:
            if x not in t._children:
                return False
            t = t._children[x]
        return t.is_end_of_word

def main():
    trie = Trie() #Initiaize trie
    allowed_words = [] #Accumulate dictionary of words
    
    # Read allowed words
    while True:
        try:
            dict_word = input().strip().lower() #Case-insensitive and striping of whitespace
        except EOFError:
            break
        if dict_word == "!":
            break
        allowed_words.append(dict_word)

    for term in allowed_words: #Add each term to the trie
        trie.add(term)

    total_words = []
    separators = set("0123456789.,'/-\":;?!() ") #More efficient than list (which was used earlier)

    # Read text lines
    while True:
        try:
            line = input().strip().lower()
        except EOFError: #Handling issue with Themis
            break
        if not line:
            break
        
        word = "" #Extract the words from each line
        for letter in line:
            if letter not in separators: #Skip the separators
                word += letter
            else:
                if word:  #Avoid empty strings
                    total_words.append(word)  
                word = ""
        
        if word:  
            total_words.append(word)  #Append last word if it exists

    unknown_words = []
    for word in total_words:
        if not trie.search_in_trie(word):  # If the word is not in the trie (hence unknown)
            unknown_words.append(word)  # Add it to the list of unknown words

    for word in unknown_words:
        print(word) #Output all unknwon words
    print(f"There are {len(unknown_words)} unknown words.")

if __name__ == "__main__": #For testing of Trie()
    main()

Time Complexity Analysis:

TrieNode Class:
    __init__: O(1) - Initializes a new Trie node with an empty dictionary.

Trie Class:
    __init__: O(1) - Initializes the Trie with a root node.
    add(word): O(m) - where m is the length of the word.
    search_in_trie(word): O(m) - where m is the length of the word.

Main Program:
    Reading allowed words: O(n) - where n is the number of allowed words.
    Adding words to Trie: O(N * m) - where N is the number of allowed words,
       and m is the average length of the allowed words.
    Reading text lines: O(L) - where L is the total length of all input lines.
    Extracting total words from text lines: O(L)
    Searching for unknown words: O(T * k) - where T is the number of total words
       and k is the average length of total words.
    Outputting unknown words: O(U) - where U is the number of unknown words.

Overall: O(N*m + L + T*k)
    N: number of allowed words.
    m: average length of allowed words.
    L: total length of input lines.
    T: number of total words in input.
    k: average length of total words.

Summary:
    The trie operations (add and search) are O(m) where m is the
    length of the word. The main program complexity is dominated by
    reading the input and processing the words.  This results in a final time
    complexity of O(N*m + L + T*k).


"""
lab4expressiontrees
"""
"""
File:   expTree_test.py
Author: Vikranth Moparthy (v.moparthy@student.rug.nl)
Description:
   A program that recognises and returns the value of a numerical infix expression. If the expression is non-numeric,
it provides the simplified version of the expression and its derivative with respect to x.
"""

class Token:
    def __init__(self, token_type: TokenType, value):
        self.type = token_type
        self.value = value

def is_operator(char: str) -> bool:
    return char in "+-*/"

def precedence(op: str) -> int: #For building tree
    if op in ('+', '-'):
        return 1
    if op in ('*', '/'): #Multiplication and division have higher priority
        return 2
    return 0

def tokenize(text: str) -> list[Token]:
    if text is None:
        return None
    tokens = []
    pos = 0
    while pos < len(text):
        while pos < len(text) and text[pos].isspace():
            pos += 1
        if pos >= len(text):
            break
        if text[pos].isdigit():
            value, pos = _match_number(text, pos)
            tokens.append(Token(TokenType.NUMBER, value))
        elif text[pos].isalpha():
            identifier, pos = _match_identifier(text, pos)
            tokens.append(Token(TokenType.IDENTIFIER, identifier))
        else:
            symbol, pos = _match_symbol(text, pos)
            tokens.append(Token(TokenType.SYMBOL, symbol))
    return tokens

def build_tree(tokens: list[Token]) -> TreeNode: #Builds tree from tokens in infix order
    values = []  # Stack for operands (list representation)
    operators = []  # Stack for operators

    def apply_operator(): #Pops operands and operator, builds subtree, pushes result. With help from: https://shorturl.at/P4f8X
        if len(values) < 2 or not operators:
            return
        right = values.pop()
        left = values.pop()
        op = operators.pop()
        node = TreeNode(Token(TokenType.SYMBOL, op.value))
        node._left = left
        node._right = right
        values.append(node)

    if not tokens or tokens[0].type == TokenType.SYMBOL and tokens[0].value not in "(":  # Reject if the expression starts with an operator
        return None

    previous_token = None

    for token in tokens:
        if token.type == TokenType.NUMBER or token.type == TokenType.IDENTIFIER:
            if previous_token and previous_token.type in [TokenType.NUMBER, TokenType.IDENTIFIER]:  # Two consecutive operands are not allowed
                return None  
            values.append(TreeNode(token))

        elif token.type == TokenType.SYMBOL:
            if token.value == "(":  # If the token is an opening parenthesis
                operators.append(token)
            elif token.value == ")":  # If the token is a closing parenthesis
                while operators and operators[-1].value != "(":  
                    apply_operator()
                if not operators:
                    return None  # Unbalanced parentheses
                operators.pop()  # Remove '('
            elif token.value in "+-*/":  # Only allow +, -, *, /
                if previous_token is None or previous_token.type == TokenType.SYMBOL and previous_token.value != ")":
                    return None  # Two consecutive operators or operator at start
                while (operators and operators[-1].value != "(" and
                       precedence(operators[-1].value) >= precedence(token.value)):  # Apply operators with higher or equal precedence before adding the current operator. Use of precedence with help from: https://shorturl.at/P4f8X
                    apply_operator()
                operators.append(token)  # Add the current operator to the stack
            else:
                return None  # Reject any operator other than +, -, *, /

        previous_token = token

    # Check if the last token is an operator, which was an edge case
    if tokens and tokens[-1].type == TokenType.SYMBOL and tokens[-1].value not in ")":
        return None  # Incomplete expression (ends with an operator)

    while operators:
        if operators[-1].value in "()":  # Unbalanced parentheses
            return None  
        apply_operator()

    if values:
        if len(values) > 1:  # If there is more than one element in values at the end, expression is incomplete
            return None
        return values[0]
    else:
        return None


def generate_expression_tree(text: str) -> TreeNode | None:

    tokens = tokenize(text)
    return build_tree(tokens)

def evaluate_expression_tree(tree: TreeNode) -> float: #Recursively evaluates an expression tree
    if tree is None:
        return None

    if tree._item.type == TokenType.NUMBER:
        return tree._item.value

    left_operand = evaluate_expression_tree(tree._left)
    right_operand = evaluate_expression_tree(tree._right)

    if left_operand is None or right_operand is None:
        return None  # If either operand is None, return None
    
    if tree._item:
        match tree._item.value:
            case '*':
                return left_operand * right_operand
            case '/':
                if right_operand == 0:
                    return None
                return left_operand / right_operand
            case '-':
                return left_operand - right_operand
            case '+':
                return left_operand + right_operand
    else:
        return None

def simplify(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None

    tree._left = simplify(tree._left)   #Recursively simplify left and right subtrees
    tree._right = simplify(tree._right)

    if tree._item.type != TokenType.SYMBOL or not (tree._left and tree._right): # Only simplify if the node is an operator and has both left and right children
        return tree

    op = tree._item.value
    left = tree._left._item
    right = tree._right._item

    if op == "+":
        if left.type == TokenType.NUMBER and left.value == 0:
            return tree._right #0 + E
        if right.type == TokenType.NUMBER and right.value == 0: #E + 0
            return tree._left

    elif op == "-":
        if right.type == TokenType.NUMBER and right.value == 0: #E - 0
            return tree._left

    elif op == "*":
        if left.type == TokenType.NUMBER and left.value == 0 or right.type == TokenType.NUMBER and right.value == 0:
            return TreeNode(Token(TokenType.NUMBER, 0)) #E * 0 or 0 * E
        if left.type == TokenType.NUMBER and left.value == 1: #1 * E
            return tree._right
        if right.type == TokenType.NUMBER and right.value == 1: #E * 1
            return tree._left

    elif op == "/":
        if right.type == TokenType.NUMBER and right.value == 1:
            return tree._left #E / 1
    return tree

def differentiate(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None
    
    if tree._item.type == TokenType.NUMBER:
        return TreeNode(Token(TokenType.NUMBER, 0)) #The derivative of a constant is 0
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value == "x":
        return TreeNode(Token(TokenType.NUMBER, 1)) #The derivative of the variable x is 1
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value != "x": #If we encounter a variable that is not x, derivative of variable with respect to x is 0.
                return TreeNode(Token(TokenType.NUMBER, 0))
    
    operator = tree._item.value #Root node should be operator
    left, right = tree._left, tree._right #Store the children

    left_derivative = differentiate(left) #Recursively define the derivatives of the children
    right_derivative = differentiate(right)

    if operator == "+":
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_derivative, right_derivative) #Derivative of additions is the addition of derivatives
    
    if operator == "-":
        return TreeNode(Token(TokenType.SYMBOL, "-"), left_derivative, right_derivative) #Derivative of subtractions is the subtraction of derivatives
        
    if operator == "*":
        left_term = TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right) #Define u'v
        right_term = TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative) #Define uv'
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_term, right_term) #Product rule states derivative is sum of u'v and uv'

    if operator == "/":
        numerator = TreeNode(Token(TokenType.SYMBOL, "-"), #Subtract u'v - uv'
                            TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right), #Define u'v
                            TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative)) #Define uv'
        denominator = TreeNode(Token(TokenType.SYMBOL, "*"), right, right) #Define v^2
        return TreeNode(Token(TokenType.SYMBOL, "/"), numerator, denominator) #Finally, derivative would be numerator / denominator
    
    return tree

def is_numerical_expression_tree(tree: TreeNode) -> bool:
    if tree is None:
        return False
    if tree._item.type == TokenType.IDENTIFIER:

        return False
    if tree._item.type == TokenType.NUMBER:
        return True
    return is_numerical_expression_tree(tree._left) and is_numerical_expression_tree(tree._right)


def infix_expression_tree(tree: TreeNode) -> str:
    if tree is None:
        return "!"
    if tree._item.type == TokenType.SYMBOL:
        return f"({infix_expression_tree(tree._left)} {tree._item.value} {infix_expression_tree(tree._right)})"
    return str(tree._item.value)


def main(): #The input code is mostly the same as Prof. de Weerd's, however it is adapted slightly to meet Themis' requirements.
    expression = input("give an expression: ")
    while expression == "" or expression[0] != "!":
        tokentree = generate_expression_tree(expression)
        if tokentree is None:
            print("this is not an infix expression")
        else:
            print("expression:", end=" ")
            print(infix_expression_tree(tokentree))
            if is_numerical_expression_tree(tokentree):
                if evaluate_expression_tree(tokentree) is not None:
                    print("the value of this expression is:", end=" ")
                    print(evaluate_expression_tree(tokentree))
                else:
                    print("this is not a numerical infix expression")
                    print("simplified:", infix_expression_tree(simplify(tokentree)))
                    print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
            else:
                print("this is not a numerical infix expression")
                print("simplified:", infix_expression_tree(simplify(tokentree)))
                print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
        expression = input("\ngive an expression: ")
    print("good bye")

main()

"""
lab4expressiontrees
"""
"""
File:   expTree_test.py
Author: Vikranth Moparthy (v.moparthy@student.rug.nl)
Description:
   A program that recognises and returns the value of a numerical infix expression. If the expression is non-numeric,
it provides the simplified version of the expression and its derivative with respect to x.
"""

class Token:
    def __init__(self, token_type: TokenType, value):
        self.type = token_type
        self.value = value

def is_operator(char: str) -> bool:
    return char in "+-*/"

def precedence(op: str) -> int: #For building tree
    if op in ('+', '-'):
        return 1
    if op in ('*', '/'): #Multiplication and division have higher priority
        return 2
    return 0

def tokenize(text: str) -> list[Token]:
    if text is None:
        return None
    tokens = []
    pos = 0
    while pos < len(text):
        while pos < len(text) and text[pos].isspace():
            pos += 1
        if pos >= len(text):
            break
        if text[pos].isdigit():
            value, pos = _match_number(text, pos)
            tokens.append(Token(TokenType.NUMBER, value))
        elif text[pos].isalpha():
            identifier, pos = _match_identifier(text, pos)
            tokens.append(Token(TokenType.IDENTIFIER, identifier))
        else:
            symbol, pos = _match_symbol(text, pos)
            tokens.append(Token(TokenType.SYMBOL, symbol))
    return tokens

def build_tree(tokens: list[Token]) -> TreeNode: #Builds tree from tokens in infix order
    values = []  # Stack for operands (list representation)
    operators = []  # Stack for operators

    def apply_operator(): #Pops operands and operator, builds subtree, pushes result. With help from: https://shorturl.at/P4f8X
        if len(values) < 2 or not operators:
            return
        right = values.pop()
        left = values.pop()
        op = operators.pop()
        node = TreeNode(Token(TokenType.SYMBOL, op.value))
        node._left = left
        node._right = right
        values.append(node)

    if not tokens or tokens[0].type == TokenType.SYMBOL and tokens[0].value not in "(":  # Reject if the expression starts with an operator
        return None

    previous_token = None

    for token in tokens:
        if token.type == TokenType.NUMBER or token.type == TokenType.IDENTIFIER:
            if previous_token and previous_token.type in [TokenType.NUMBER, TokenType.IDENTIFIER]:  # Two consecutive operands are not allowed
                return None  
            values.append(TreeNode(token))

        elif token.type == TokenType.SYMBOL:
            if token.value == "(":  # If the token is an opening parenthesis
                operators.append(token)
            elif token.value == ")":  # If the token is a closing parenthesis
                while operators and operators[-1].value != "(":  
                    apply_operator()
                if not operators:
                    return None  # Unbalanced parentheses
                operators.pop()  # Remove '('
            elif token.value in "+-*/":  # Only allow +, -, *, /
                if previous_token is None or previous_token.type == TokenType.SYMBOL and previous_token.value != ")":
                    return None  # Two consecutive operators or operator at start
                while (operators and operators[-1].value != "(" and
                       precedence(operators[-1].value) >= precedence(token.value)):  # Apply operators with higher or equal precedence before adding the current operator. Use of precedence with help from: https://shorturl.at/P4f8X
                    apply_operator()
                operators.append(token)  # Add the current operator to the stack
            else:
                return None  # Reject any operator other than +, -, *, /

        previous_token = token

    # Check if the last token is an operator, which was an edge case
    if tokens and tokens[-1].type == TokenType.SYMBOL and tokens[-1].value not in ")":
        return None  # Incomplete expression (ends with an operator)

    while operators:
        if operators[-1].value in "()":  # Unbalanced parentheses
            return None  
        apply_operator()

    if values:
        if len(values) > 1:  # If there is more than one element in values at the end, expression is incomplete
            return None
        return values[0]
    else:
        return None


def generate_expression_tree(text: str) -> TreeNode | None:

    tokens = tokenize(text)
    return build_tree(tokens)

def evaluate_expression_tree(tree: TreeNode) -> float: #Recursively evaluates an expression tree
    if tree is None:
        return None

    if tree._item.type == TokenType.NUMBER:
        return tree._item.value

    left_operand = evaluate_expression_tree(tree._left)
    right_operand = evaluate_expression_tree(tree._right)

    if left_operand is None or right_operand is None:
        return None  # If either operand is None, return None
    
    if tree._item:
        match tree._item.value:
            case '*':
                return left_operand * right_operand
            case '/':
                if right_operand == 0:
                    return None
                return left_operand / right_operand
            case '-':
                return left_operand - right_operand
            case '+':
                return left_operand + right_operand
    else:
        return None

def simplify(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None

    tree._left = simplify(tree._left)   #Recursively simplify left and right subtrees
    tree._right = simplify(tree._right)

    if tree._item.type != TokenType.SYMBOL or not (tree._left and tree._right): # Only simplify if the node is an operator and has both left and right children
        return tree

    op = tree._item.value
    left = tree._left._item
    right = tree._right._item

    if op == "+":
        if left.type == TokenType.NUMBER and left.value == 0:
            return tree._right #0 + E
        if right.type == TokenType.NUMBER and right.value == 0: #E + 0
            return tree._left

    elif op == "-":
        if right.type == TokenType.NUMBER and right.value == 0: #E - 0
            return tree._left

    elif op == "*":
        if left.type == TokenType.NUMBER and left.value == 0 or right.type == TokenType.NUMBER and right.value == 0:
            return TreeNode(Token(TokenType.NUMBER, 0)) #E * 0 or 0 * E
        if left.type == TokenType.NUMBER and left.value == 1: #1 * E
            return tree._right
        if right.type == TokenType.NUMBER and right.value == 1: #E * 1
            return tree._left

    elif op == "/":
        if right.type == TokenType.NUMBER and right.value == 1:
            return tree._left #E / 1
    return tree

def differentiate(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None
    
    if tree._item.type == TokenType.NUMBER:
        return TreeNode(Token(TokenType.NUMBER, 0)) #The derivative of a constant is 0
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value == "x":
        return TreeNode(Token(TokenType.NUMBER, 1)) #The derivative of the variable x is 1
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value != "x": #If we encounter a variable that is not x, derivative of variable with respect to x is 0.
                return TreeNode(Token(TokenType.NUMBER, 0))
    
    operator = tree._item.value #Root node should be operator
    left, right = tree._left, tree._right #Store the children

    left_derivative = differentiate(left) #Recursively define the derivatives of the children
    right_derivative = differentiate(right)

    if operator == "+":
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_derivative, right_derivative) #Derivative of additions is the addition of derivatives
    
    if operator == "-":
        return TreeNode(Token(TokenType.SYMBOL, "-"), left_derivative, right_derivative) #Derivative of subtractions is the subtraction of derivatives
        
    if operator == "*":
        left_term = TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right) #Define u'v
        right_term = TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative) #Define uv'
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_term, right_term) #Product rule states derivative is sum of u'v and uv'

    if operator == "/":
        numerator = TreeNode(Token(TokenType.SYMBOL, "-"), #Subtract u'v - uv'
                            TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right), #Define u'v
                            TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative)) #Define uv'
        denominator = TreeNode(Token(TokenType.SYMBOL, "*"), right, right) #Define v^2
        return TreeNode(Token(TokenType.SYMBOL, "/"), numerator, denominator) #Finally, derivative would be numerator / denominator
    
    return tree

def is_numerical_expression_tree(tree: TreeNode) -> bool:
    if tree is None:
        return False
    if tree._item.type == TokenType.IDENTIFIER:

        return False
    if tree._item.type == TokenType.NUMBER:
        return True
    return is_numerical_expression_tree(tree._left) and is_numerical_expression_tree(tree._right)


def infix_expression_tree(tree: TreeNode) -> str:
    if tree is None:
        return "!"
    if tree._item.type == TokenType.SYMBOL:
        return f"({infix_expression_tree(tree._left)} {tree._item.value} {infix_expression_tree(tree._right)})"
    return str(tree._item.value)


def main(): #The input code is mostly the same as Prof. de Weerd's, however it is adapted slightly to meet Themis' requirements.
    expression = input("give an expression: ")
    while expression == "" or expression[0] != "!":
        tokentree = generate_expression_tree(expression)
        if tokentree is None:
            print("this is not an infix expression")
        else:
            print("expression:", end=" ")
            print(infix_expression_tree(tokentree))
            if is_numerical_expression_tree(tokentree):
                if evaluate_expression_tree(tokentree) is not None:
                    print("the value of this expression is:", end=" ")
                    print(evaluate_expression_tree(tokentree))
                else:
                    print("this is not a numerical infix expression")
                    print("simplified:", infix_expression_tree(simplify(tokentree)))
                    print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
            else:
                print("this is not a numerical infix expression")
                print("simplified:", infix_expression_tree(simplify(tokentree)))
                print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
        expression = input("\ngive an expression: ")
    print("good bye")

main()
"""
lab5trainsinthestorm
"""

"""
File:   trainsinthestorms.py
Authors: Vikranth Moparthy (v.moparthy@student.rug.nl), Prof. Harmen de Weerd (harmen.de.weerd@rug.nl)

Description:
    A program that finds the fastest train connections between a pair of cities in the Netherlands given a network of connections of many cities and travel times between them. 
    Also factors in possible disruptions.
"""
#from ADS import GraphEdge, UndirectedGraph, Heap

def dijkstra(G: UndirectedGraph, start: int) -> tuple[dict, dict]:
    distances = {node: float('inf') for node in range(len(G._neighbours))}  #Initally all distances to all nodes are infinity 
    predecessors = {node: None for node in range(len(G._neighbours))} #Keeping track of path
    distances[start] = 0 #Node distance to itself is 0

    heap = Heap() #Implementing heap for inverted priority queue
    heap.enqueue((0, start))

    while heap.size > 0: 
        current_dist, u = heap.remove_min() #Node with minimal distance from 
        
        # Skip processed nodes with outdated distances
        if current_dist > distances[u]:
            continue
            
        # Explore neighbors
        for edge in G._neighbours[u]:
            v = edge.other_node(u)
            weight = edge.get_weight()
                # If a shorter path to v is found
            new_dist = distances[u] + weight

            if new_dist < distances[v]:
                distances[v] = new_dist
                predecessors[v] = u
                heap.enqueue((new_dist, v)) #Add v to heap for further exploration

    paths = {} #Backtracking paths
    for node in range(len(G._neighbours)):
        if distances[node] == float('inf'): #In case a path does not exist
            paths[node] = None
            continue
            
        path = []
        current = node
        while current is not None:
            path.append(current)
            current = predecessors[current]
        paths[node] = path[::-1]  # Reverse to get start->end order

    return distances, paths

def main():
    G = UndirectedGraph(12)
    nodes = {
        "Den Helder": 0, "Amsterdam": 1, "Den Haag": 2, "Utrecht": 3, "Eindhoven": 4, 
        "Maastricht": 5, "Nijmegen": 6, "Zwolle": 7, "Enschede": 8, "Meppel": 9, 
        "Leeuwarden": 10, "Groningen": 11
    } #Map each city to a number

     #Add all the connections as given in the question
    G.add_edge(nodes["Amsterdam"], nodes["Den Haag"], 46)
    G.add_edge(nodes["Amsterdam"], nodes["Den Helder"], 77)
    G.add_edge(nodes["Amsterdam"], nodes["Utrecht"], 26)
    G.add_edge(nodes["Den Haag"], nodes["Eindhoven"], 89)
    G.add_edge(nodes["Eindhoven"], nodes["Maastricht"], 63)
    G.add_edge(nodes["Eindhoven"], nodes["Nijmegen"], 55)
    G.add_edge(nodes["Eindhoven"], nodes["Utrecht"], 47)
    G.add_edge(nodes["Enschede"], nodes["Zwolle"], 50)
    G.add_edge(nodes["Groningen"], nodes["Leeuwarden"], 34)
    G.add_edge(nodes["Groningen"], nodes["Meppel"], 49)
    G.add_edge(nodes["Leeuwarden"], nodes["Meppel"], 40)
    G.add_edge(nodes["Maastricht"], nodes["Nijmegen"], 111)
    G.add_edge(nodes["Meppel"], nodes["Zwolle"], 15)
    G.add_edge(nodes["Nijmegen"], nodes["Zwolle"], 77)
    G.add_edge(nodes["Utrecht"], nodes["Zwolle"], 51)

    input_lines = [] #First take all input
    while True:
        line = input().strip()
        if line == "!":
            break
        input_lines.append(line)
    
    # Process disruptions
    n = int(input_lines[0])
    idx = 1
    for _ in range(n):
        city1 = input_lines[idx]
        city2 = input_lines[idx+1]
        G.remove_edge(nodes[city1], nodes[city2]) #Remove edges where disruptions occur, because there exists no connection between them
        idx += 2
    
    # Process queries
    while idx < len(input_lines):
        start = input_lines[idx]
        end = input_lines[idx+1]
        idx += 2
        
        start_node = nodes.get(start)
        end_node = nodes.get(end)
        
        if start_node is None or end_node is None:
            print("UNREACHABLE") #Incomplete or erroneous input
            continue
        
        distances, paths = dijkstra(G, start_node)
        
        if distances[end_node] == float("inf"): #Case where distance is infinity
            print("UNREACHABLE")
        else:
            path = paths[end_node] #Extract the path to the required destination node
            for node in path:
                city = next(k for k, v in nodes.items() if v == node) #How to get key given value in dictionary. Source: https://shorturl.at/p5h1S
                print(city)
            print(distances[end_node])

main()

# Time Complexity Analysis:
# - V: Number of vertices (cities in the graph).
# - E: Number of edges (connections between cities).
# - Initialization (distances, predecessors): O(V)
# - Enqueue operation (heap insertion): O(V log V)
# - Remove_min (linear search + downheap): O(V^2), as it's called once per vertex and costs O(V) per call.
# - Edge relaxation (updating distances and enqueueing neighbors): O(E log V)
# Overall: O(V^2 + E log V) due to inefficient remove_min.
"""
Tutorial Code / Additional Code

"""

#2.3: Stack from one or more queues

class StackUsingQueue:
    def __init__(self):
        self.queue1 = Queue()
        self.queue2 = Queue()

    def push(self, item):
        self.queue1.enqueue(item)

    def pop(self):
        if self.queue1.size() == 0:
            print("Stack is empty!")
            return None

        # Move all elements from queue1 to queue2, except the last one
        while self.queue1.size() > 1:
            self.queue2.enqueue(self.queue1.dequeue())
        
        # The last element in queue1 is the one to pop
        item = self.queue1.dequeue()

        # Swap queues
        self.queue1, self.queue2 = self.queue2, self.queue1

        return item
    
#2.4: Checking if parenthetical expression in balanced

def is_balanced(s):
    stack = Stack()
    for i in s:
        if i == "(" or i == "[":
            stack.push(i)
        elif i == "]":
            if stack.size() == 0 or stack.pop() != "[":
                print("unbalanced")
                return
        elif i == ")":
            if stack.size() == 0 or stack.pop() != "(":
                print("unbalanced")
                return
    if stack.size() != 0:
        print("unbalanced")
    else:
        print("balanced")

#2.6: Pop method in Queue()

def pop(self):
    """
    Retrieve and remove the value that was added last
    :return: the item that was added last to the queue
    """
    if self.size() == 0:
        print("Queue empty!")
        return None
    
    val = self._q[self._back - 1]
    self._back = (self._back - 1) % len(self._q)
    return val

#2.7: Pop in stack removes max element

def pop(self):
    """
    Removes and returns the item on top of the stack
    :return: item on top of the stack
    """
    max_ = max(self._stack)
    self._stack.remove(max_)
    return max_

#2.8: Copy a stack

def copy_stack_recursively(stack):
    """
    Function to copy a stack recursively.
    """
    # Base case: If the stack is empty, return an empty list (representing an empty stack)
    if not stack:
        return []

    # Step 1: Pop the top element from the stack
    top_element = stack.pop()

    # Step 2: Copy the rest of the stack recursively
    copied_stack = copy_stack_recursively(stack)

    # Step 3: Push the popped element to the copied stack to maintain order
    copied_stack.append(top_element)

    # Step 4: Push the element back to the original stack to preserve its state
    stack.append(top_element)

    return copied_stack

#2.11: LinkedList method to find whether a particular value exists. (Iterative solution)

def find(self, value):
    while self._next is not None and self._next._item != value:
        self = self._next
    if self._next is None:
        return False
    else:
        return True

#2.12: LinkedList method to remove all nodes from a list with a given value
def remove_all(self, value):
    if self._next is None:
        return
    if self._next._item == value:
        self.remove_first_item()
        self.remove_all(value)
    else:
        self._next.remove_all(value)

#2.13: LinkedList method to remove a node at a given position from a list
def remove_at_index(self, pos):
    if pos > self.size():
        return self._list_too_short_error()
    if pos == 0:
        self.remove_first_item()
    if self._next is not None:
        return self._next.remove_at_index(pos - 1)
    
#2.15 LinkedList method to remove last occurence of a given value
def remove_last_occurrence(self, value) -> None:

    prev_last = None  # Track predecessor of the last occurrence
    prev = self       # Current predecessor node during traversal
    current = self._next  # Current node being checked
    
    # Traverse the entire list
    while current is not None:
        if current._item == value:
            prev_last = prev  # Update last found position
        prev = current
        current = current._next
    
    # Remove the node if found
    if prev_last is not None:
        prev_last._next = prev_last._next._next
    else:
        self._value_not_found_error()

#2.16: LinkedList method to remove consecutive duplicate values
def remove_duplicates(self):
    if self._next is None:
        return
    if self._next._next is not None and self._next._item == self._next._next._item:
        self._next = self._next._next  # Remove duplicate
        self.remove_duplicates()  # Continue checking
    else:
        self._next.remove_duplicates()  # Move to next node


#3.3 a) Function to copy a tree
def copy_tree(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None
    return TreeNode(tree._item, copy_tree(tree._left), copy_tree(tree._right))

#3.3 b) Get height of tree
def tree_height(tree: TreeNode) -> int:
    if tree is None:
        return -1  # Return -1 so that a single-node tree has height 0
    
    left_height = tree_height(tree._left)
    right_height = tree_height(tree._right)
    
    return 1 + max(left_height, right_height)


#3.3 c) Number of nodes in tree
def node_number(tree: TreeNode) -> int:
    if tree is None:
        return 0
    return 1 + node_number(tree._left) + node_number(tree._right)

#3.3 d) Find node with max value
def find_max_node(tree: TreeNode) -> int | None:
    if not tree:
        return None
    current = tree
    while current._right is not None:
        current = current._right
    return current._item

#3.3 e) Highest position that contains a rode

def is_search_tree(root: TreeNode) -> bool:
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node:
            return True
        if not (low < node._item < high):
            return False
        return (validate(node._left, low, node._item) and 
                validate(node._right, node._item, high))
    return validate(root)

#3.4: Finds node with a given position, n

def find_node(tree: TreeNode, pos: int) -> TreeNode:
    if tree is None:
        return None
    
    if pos == 1:
        return tree
    
    parent_pos = pos // 2

    if pos % 2 == 0:
        return find_node(tree._left, parent_pos)
    else:
        return find_node(tree._right, parent_pos)
    
#3.7 Tree to list
def tree_to_list(tree: TreeNode, index=1, result=None) -> list:
    if result is None:
        result = []
    
    # Ensure the list is large enough for the current index
    while len(result) < index:
        result.append(None)
    
    result[index - 1] = tree._item  # 1-based index adjustment

    if tree._left:
        tree_to_list(tree._left, index * 2, result)  # Left child at index * 2
    if tree._right:
        tree_to_list(tree._right, index * 2 + 1, result)  # Right child at index * 2 + 1

    return result

#3.8 a) Inorder Successor
def inorder_successor(node: TreeNode) -> TreeNode:
    if node._right is not None:
        w = node._right
        while w._left is not None:
            w = w._left
        return w
    return None

def remove_from_search_tree(tree: TreeNode, value: int) -> TreeNode:
    # Step 1: Search for the node to remove
    node = tree
    parent = None
    
    # Find the node
    while node is not None and node._item != value:
        parent = node
        if value < node._item:
            node = node._left
        else:
            node = node._right

    if node is None:
        return tree  # Value not found, return tree as is

    # Step 2: Node found, remove the node based on number of children
    # Case 1: Node has no children (leaf node)
    if node._left is None and node._right is None:
        if parent is None:
            return None  # If root node is to be deleted, return None
        if parent._left == node:
            parent._left = None
        else:
            parent._right = None
    
    # Case 2: Node has one child
    elif node._left is None or node._right is None:
        child = node._left if node._left is not None else node._right
        if parent is None:
            return child  # If root node is to be deleted, return its only child
        if parent._left == node:
            parent._left = child
        else:
            parent._right = child
    
    # Case 3: Node has two children
    else:
        # Find the inorder successor
        successor = inorder_successor(node)
        
        # Replace node's value with the successor's value
        node._item = successor._item
        
        # Now remove the successor node
        remove_from_search_tree(node._right, successor._item)  # Successor is always in the right subtree

    return tree

#Time complextity: Worst case: O(H), Balanced tree: O(log H), where H is the height of the tree

#3.10: Function to upheap (already there)

#3.11: Function to downheap (already there)


"""
Additional Useful Functions
"""
def dijkstra_with_paths(G: UndirectedGraph, start: int) -> tuple[dict, dict]: #Dijkstra's algorithm with shortest path
    distances = {node: float('inf') for node in range(len(G._neighbours))}
    predecessors = {node: None for node in range(len(G._neighbours))}
    distances[start] = 0

    heap = Heap()
    heap.enqueue((0, start))

    while heap.size > 0:
        current_dist, u = heap.remove_min()

        if current_dist > distances[u]:
            continue

        for edge in G._neighbours[u]:
            v = edge.other_node(u)
            weight = edge.get_weight()
            new_dist = distances[u] + weight

            if new_dist < distances[v]:
                distances[v] = new_dist
                predecessors[v] = u
                heap.enqueue((new_dist, v))

    paths = {}
    for node in range(len(G._neighbours)):
        if distances[node] == float('inf'):
            paths[node] = None
        else:
            path = []
            current = node
            while current is not None:
                path.append(current)
                current = predecessors[current]
            paths[node] = path[::-1]

    return distances, paths

"""
The graph uses an adjacency list → total neighbor checks = O(E)
The custom heap’s remove_min() scans the whole heap → O(N) per call
The heap can grow up to O(E) elements (one per edge)
Up to O(E) calls to enqueue → O(E log E) total
Up to O(E) calls to remove_min() → O(E²) total
Reconstructing paths takes O(V²) in worst case
Total time complexity: O(E² + V²)
"""

# Tutorial / Additional Code: Time Complexity Summary:

# StackUsingQueue:
# push: O(1) - Simple enqueue operation.
# pop: O(n) - Transfers all elements except the last one to another queue.

# is_balanced (Balanced Parentheses):
# O(n) - Each character is processed once with stack operations.

# Queue pop method:
# pop: O(1) - Direct index manipulation.

# Stack pop (removes max element):
# pop: O(n) - Scans all elements to find and remove the maximum.

# Copy stack recursively:
# O(n^2) - Repeated stack traversal during recursion.

# LinkedList methods:
# find: O(n) - Sequential traversal to find a value.
# remove_all: O(n) - Recursively removes all nodes with a given value.
# remove_at_index: O(n) - Traverses nodes up to the specified index.
# remove_last_occurrence: O(n) - Traverses all nodes to find and remove the last occurrence.
# remove_duplicates: O(n) - Recursively checks consecutive nodes for duplicates.

# Tree functions:
# copy_tree: O(n) - Visits all nodes to copy them.
# tree_height: O(n) - Calculates height by visiting all nodes once.
# node_number: O(n) - Counts all nodes recursively.
# find_max_node: O(h) - Traverses along the rightmost path (height h).
# is_search_tree: O(n) - Validates each node recursively using range constraints.
# find_node: O(h) - Traverses down to a specific position (height h).
# tree_to_list: O(n) - Visits all nodes to convert them into a list representation.
# inorder_successor: O(h) - Traverses leftmost nodes in a subtree (height h).
# remove_from_search_tree:
#   Worst case: O(h), where h is the height of the tree.
#   Balanced tree: O(log n), where n is the number of nodes.

# Dijkstra's Algorithm:
# dijkstra_with_paths:
# Total time complexity: O(E² + V²), where E is the number of edges and V is the number of vertices.
