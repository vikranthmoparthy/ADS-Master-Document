"""
File Name: ADS_Master_Document.py
Details: Contains all assignment and tutorial code, as well as data structure code, time complexity information and additional functionality
"""

"""
General Data Structures
"""

"""
Stacks
"""

class Stack:
    """
    Creates a stack that allows for last-in-first-out (LIFO) access
    """

    def __init__(self):
        self._stack = []

    def push(self, item) -> None:
        """
        Adds an item to the top of the stack
        :param item: item to add
        """
        self._stack.append(item)

    def pop(self):
        """
        Removes and returns the item on top of the stack
        :return: item on top of the stack
        """
        return self._stack.pop()

    def size(self) -> int:
        """
        Returns the number of items on the stack
        :return: number of items on the stack
        """
        return len(self._stack)
    
    def to_list(self):
        """
        Returns a list of all items in the stack from bottom to top.
        :return: list of items in LIFO order (bottom to top)
        """
        return self._stack[:]

# Time Complexity Analysis for Stack Class:

# push(item): O(1)
# Appends an item to the end of the list. In Python, appending to a list is an O(1) operation in the average case.

# pop(): O(1)
# Removes and returns the last item from the list. Popping from the end of a list is an O(1) operation in Python.

# size(): O(1)
# Returns the length of the list using len(). The len() function in Python is an O(1) operation as it directly accesses the stored size of the list.

# to_list(): O(n)
# Returns a shallow copy of the list using slicing. Slicing a list has a time complexity of O(n), where n is the number of elements in the list.

"""
Queues
"""

class Queue:
    """
    Creates a first-in-first-out (FIFO) queue
    """

    def __init__(self):
        self._q = [0, 0]
        self._front = 0
        self._back = 0

    def size(self) -> int:
        """
        Returns the number of items in the queue
        :return: number of items in the queue
        """
        size = self._back - self._front
        if self._front > self._back:
            size += len(self._q)
        return size

    def dequeue(self):
        """
        Removed and returns the oldest item in the queue
        :return: the item that has been in the queue the longest
        """
        if self.size() == 0:
            print("Queue empty!")
            return None
        item = self._q[self._front]
        self._front = (self._front + 1) % len(self._q)
        return item

    def enqueue(self, item) -> None:
        """
        Adds an item to the end of the queue
        :param item: item to add to the queue
        """
        self._q[self._back] = item
        self._back = (self._back + 1) % len(self._q)
        if self._back == self._front:
            self._back += len(self._q)
            self._q.extend(self._q)
    
    def to_list(self):
        """
        Returns a list of all items in the queue in order.
        :return: list of items in FIFO order
        """
        if self.size() == 0:
            return []
        
        if self._front < self._back:
            return self._q[self._front:self._back]
        else:
            return self._q[self._front:] + self._q[:self._back]

# Time Complexity Analysis for Queue Class:

# __init__(): O(1)
# Initializes the queue with a fixed-size list and sets the front and back pointers.

# size(): O(1)
# Calculates the size of the queue using simple arithmetic operations.

# dequeue(): O(1)
# Removes and returns the front item from the queue. Uses modulo arithmetic for circular queue implementation.

# enqueue(item): O(1) amortized, O(n) worst case
# Adds an item to the end of the queue. Amortized O(1) because extending the list is infrequent, but when it does occur, it takes O(n) time, where n is the current size of the queue.

# to_list(): O(n)
# Returns a list of all items in the queue by iterating through the circular buffer.

"""
LinkedList
"""

class LinkedList:
    """
    Creates a linked list data structure
    """
    def __init__(self, item = None, next = None):
        self._item = item
        self._next = next

    def _list_empty_error(self) -> None:
        print("List empty")


    def get_first_item(self):
        """
        Returns the first value stored in the linked list
        :return: the first value stored in the linked list
        """
        if self._next is None:
            self._list_empty_error()
            return None
        return self._next._item

    def remove_first_item(self):
        """
        Returns and removes the first value stored in the linked list
        :return: the first value stored in the linked list
        """
        if self._next is None:
            self._list_empty_error()
            return None
        item = self._next._item
        self._next = self._next._next
        return item

    def size(self) -> int:
        """
        Returns the number of items stored in the linked list
        :return: the number of items stored in the linked list
        """
        size = 0
        node = self._next
        while node is not None:
            size += 1
            node = node._next
        return size

    def visit(self, action) -> None:
        """
        Performs an action for every item stored on the list
        :param action: function that takes the value of a node as input
        """
        if self._next is not None:
            action(self._next._item)
            self._next.visit(action)

    def _invalid_position(self) -> None:
        print("Invalid position")

    def _list_too_short_error(self) -> None:
        print("Linked list is too short")

    def get_item(self, pos: int):
        """
        Returns the item at the given position in the linked list
        :param pos: position of the item to return
        :return: the item at the given position in the linked list
        """
        if pos < 0:
            self._invalid_position()
            return None
        if self._next is None:
            self._list_too_short_error()
            return None
        if pos == 0:
            return self._next._item
        return self._next.get_item(pos - 1)

    def add(self, item, pos: int = 0) -> None:
        """
        Adds an item to the linked list
        :param item: item to add
        :param pos: position to add the item (by default at the start of the linked list)
        """
        if pos < 0:
            self._invalid_position()
        elif pos == 0:
            self._next = LinkedList(item, self._next)
        elif self._next is not None:
            self._next.add(item, pos - 1)
        else:
            self._list_too_short_error()

    def _value_not_found_error(self):
        print("Value not found")

    def remove(self, value) -> None:
        """
        Removes the first occurrence of a given value
        :param value: value to remove
        """
        if self._next is not None:
            if self._next._item == value:
                self.remove_first_item()
            else:
                self._next.remove(value)
        else:
            self._value_not_found_error()

    def remove_iterative(self, value) -> None:
        node = self
        while node._next is not None and node._next._item != value:
            node = node._next
        if node._next is not None:
            node._next = node._next._next
        else:
            self._value_not_found_error()

# Time Complexity Analysis for LinkedList Class:

# __init__(item=None, next=None): O(1)
# Initializes a new node with given item and next pointer.

# _list_empty_error(): O(1)
# Prints an error message.

# get_first_item(): O(1)
# Returns the first item in the list (if it exists).

# remove_first_item(): O(1)
# Removes the first item in the list (if it exists).

# size(): O(n)
# Iterates through the list to count the number of items.

# visit(action): O(n)
# Recursively applies the given action to each item in the list.

# _invalid_position(): O(1)
# Prints an error message.

# _list_too_short_error(): O(1)
# Prints an error message.

# get_item(pos): O(n)
# Recursively traverses the list to find the item at the given position.

# add(item, pos=0): O(n)
# Recursively traverses the list to add the item at the given position.

# _value_not_found_error(): O(1)
# Prints an error message.

# remove(value): O(n)
# Recursively traverses the list to remove the first occurrence of the given value.

# remove_iterative(value): O(n)
# Iteratively traverses the list to remove the first occurrence of the given value.

"""
Trees
"""

class TreeNode:

    def __init__(self, item=None, left=None, right=None):
        self._item = item
        self._height = 0
        self._left = left
        self._right = right

    def _update_height(self) -> None:
        self._height = 0
        if self._left is not None:
            self._height = max(self._height, self._left._height + 1)
        if self._right is not None:
            self._height = max(self._height, self._right._height + 1)

    
    def _get_height_imbalance(self) -> int:
        imbalance = 0
        if self._left is not None:
            imbalance -= self._left._height
        if self._right is not None:
            imbalance += self._right._height
        return imbalance

    #Traversals
    def preorder(self, action):
        action(self._item)
        if self._left is not None:
            self._left.preorder(action)
        if self._right is not None:
            self._right.preorder(action)

    def postorder(self, action):
        if self._left is not None:
            self._left.postorder(action)
        if self._right is not None:
            self._right.postorder(action)
        action(self._item)

    def inorder(self, action):
        if self._left is not None:
            self._left.inorder(action)
        action(self._item)
        if self._right is not None:
            self._right.inorder(action)

# Time Complexity Analysis for TreeNode Class:

# __init__(item=None, left=None, right=None): O(1)
# Initializes a new node with given item, height, and child pointers.

# _update_height(): O(1)
# Updates the height of the current node based on the heights of its children.

# _get_height_imbalance(): O(1)
# Calculates the height imbalance of the current node based on the heights of its children.

# preorder(action): O(n)
# Recursively applies the given action to each node in a preorder traversal.

# postorder(action): O(n)
# Recursively applies the given action to each node in a postorder traversal.

# inorder(action): O(n)
# Recursively applies the given action to each node in an inorder traversal.


#Search for a value in tree       
def search_in_search_tree(tree: TreeNode, value):
    if tree is None:
        return tree
    if value == tree._item:
        return tree
    if value < tree._item:
        return search_in_search_tree(tree._left, value)
    return search_in_search_tree(tree._right, value)

#Add to a search tree
def add_in_search_tree(tree: TreeNode, value) -> TreeNode:
    if tree is None:
        return TreeNode(value)
    if value < tree._item:
        tree._left = add_in_search_tree(tree._left, value)
        tree._update_height()
    elif value > tree._item:
        tree._right = add_in_search_tree(tree._right, value)
        tree._update_height()
    return tree

def _rotate_clockwise(tree: TreeNode) -> TreeNode:
    new_root = tree._left
    tree._left = new_root._right
    new_root._right = tree
    tree._update_height()
    new_root._update_height()
    return new_root

def _rotate_anticlockwise(tree: TreeNode) -> TreeNode:
    new_root = tree._right
    tree._right = new_root._left
    new_root._left = tree
    tree._update_height()
    new_root._update_height()
    return new_root

def _rebalance_tree(tree: TreeNode) -> TreeNode:
    imbalance = tree._get_height_imbalance()
    if imbalance <= -2:
        if tree._left._get_height_imbalance() <= 0:
            return _rotate_clockwise(tree)
        else:
            tree._left = _rotate_anticlockwise(tree._left)
            return _rotate_clockwise(tree)
    elif imbalance >= 2:
        if tree._right._get_height_imbalance() >= 0:
            return _rotate_anticlockwise(tree)
        else:
            tree._right = _rotate_clockwise(tree._right)
            return _rotate_anticlockwise(tree)
    return tree

# Time Complexity Analysis for Search Tree Functions:

# search_in_search_tree(tree, value):
# O(h) - where h is the height of the tree. In a balanced tree, h is log(n),
# but in the worst case (e.g., skewed tree), it can be O(n).

# add_in_search_tree(tree, value):
# O(h) - where h is the height of the tree for the same reasons as above.
# Includes an O(1) call to _update_height().

# _rotate_clockwise(tree):
# O(1) - Simple pointer manipulations. Includes two O(1) calls to _update_height().

# _rotate_anticlockwise(tree):
# O(1) - Simple pointer manipulations. Includes two O(1) calls to _update_height().

# _rebalance_tree(tree):
# O(1) - Simple height checks and calls to rotate, which are O(1).


"""
Heaps
"""

class Heap:
    def __init__(self):
        self._heap = [0]

    def size(self) -> int:
        return len(self._heap) - 1

    def _heap_empty_error(self) -> None:
        print("Heap empty")

    def _upheap(self, index: int) -> None:
        if index == 1:  
            return
        parent_index = index // 2  # Parent node index
        if self._heap[parent_index] < self._heap[index]:  # Max heap condition
            self._heap[index], self._heap[parent_index] = self._heap[parent_index], self._heap[index]
            self._upheap(parent_index)

    def enqueue(self, value) -> None:
        self._heap.append(value)
        self._upheap(len(self._heap) - 1)

    def _downheap(self, index: int) -> None:
        left = 2 * index
        right = (2 * index) + 1
        v = self._heap[index]

        if left < len(self._heap):
            lc = self._heap[left]
        else:
            lc = None

        if right < len(self._heap):
            rc = self._heap[right]
        else:
            rc = None

        if lc is not None or rc is not None:
            if lc is not None and rc is not None:
                if lc >= rc and lc > v:
                    self._heap[left], self._heap[index] = self._heap[index], self._heap[left]
                    self._downheap(left)
                elif rc > v:
                    self._heap[right], self._heap[index] = self._heap[index], self._heap[right]
                    self._downheap(right)

            elif lc is not None and lc > v:
                self._heap[left], self._heap[index] = self._heap[index], self._heap[left]
                self._downheap(left)

            elif rc is not None and rc > v:
                self._heap[right], self._heap[index] = self._heap[index], self._heap[right]
                self._downheap(right)

    def remove_max(self):
        if self.size() == 0:
            self._heap_empty_error()
            return None
        if self.size() == 1:
            return self._heap.pop()
        
        return_value = self._heap[1]
        self._heap[1] = self._heap.pop()
        self._downheap(1)
        return return_value

    def remove_min(self):
        if self.size() == 0:
            self._heap_empty_error()
            return None
        if self.size() == 1:
            return self._heap.pop()

        min_index = 1  # Start from the first element (root)
        for i in range(2, len(self._heap)):  # Find the minimum in the heap
            if self._heap[i] < self._heap[min_index]:
                min_index = i

        return_value = self._heap[min_index]
        self._heap[min_index] = self._heap.pop()  # Replace with the last element

        if min_index < len(self._heap):  
            self._downheap(min_index)  # Restore heap property if needed

        return return_value

# Time Complexity Analysis for Heap Class:

# __init__(): O(1)
# Initializes the heap with an initial list containing a placeholder element.

# size(): O(1)
# Returns the number of elements in the heap (excluding the placeholder).

# _heap_empty_error(): O(1)
# Prints an error message if the heap is empty.

# _upheap(index): O(log n)
# Moves an element up the heap to maintain heap property.

# enqueue(value): O(log n)
# Adds a new element to the end of the heap and then calls _upheap to maintain heap property.

# _downheap(index): O(log n)
# Moves an element down the heap to maintain heap property.

# remove_max(): O(log n)
# Removes the maximum element from the heap (root) and then calls _downheap to maintain heap property.

# remove_min(): O(n)
# Removes the minimum element from the heap. Needs to iterate through all elements and then calls _downheap.


"""
GraphEdge
"""

class GraphEdge:
    def __init__(self, origin, destination, weight: float = 1.0):
        self._origin = origin
        self._destination = destination
        self._weight = weight

    def is_incident(self, node: int) -> bool:
        return node == self._origin or node == self._destination

    def other_node(self, node: int) -> int:
        if self.is_incident(node):
            return self._origin + self._destination - node
        return -1

    def get_weight(self) -> float:
        return self._weight

# Time Complexity Analysis for GraphEdge Class:

# __init__(origin, destination, weight=1.0): O(1)
# Initializes a new edge with the given origin, destination, and weight.

# is_incident(node): O(1)
# Checks if the given node is incident to the edge.

# other_node(node): O(1)
# Returns the other node connected by the edge.

# get_weight(): O(1)
# Returns the weight of the edge.

"""
UndirectedGraph - List Representation
"""

class UndirectedGraph:
    def __init__(self, node_count: int):
        self._neighbours = [[] for _ in range(node_count)]

    def add_edge(self, node1: int, node2: int, weight: int = 1):
        new_edge = GraphEdge(node1, node2, weight)
        self._neighbours[node1].append(new_edge)
        self._neighbours[node2].append(new_edge)

# Time Complexity Analysis for UndirectedGraph Class (List Representation):

# __init__(node_count): O(n)
# Initializes the graph with a list of empty lists (adjacency lists) for each node.

# add_edge(node1, node2, weight=1): O(1)
# Adds an edge between node1 and node2.


"""
UndirectedGraph - Matrix Representation
"""

class UndirectedGraph:
    def __init__(self, node_count: int):
        self._edges = [[None] * node_count for _ in range(node_count)]

    def add_edge(self, node1: int, node2: int, weight: int = 1):
        self._edges[node1][node2] = weight
        self._edges[node2][node1] = weight

# Time Complexity Analysis for UndirectedGraph (Matrix Representation) Class:

# __init__(node_count): O(n^2)
# Initializes the graph with a matrix of size n x n (n = node_count).

# add_edge(node1, node2, weight=1): O(1)
# Adds an edge between node1 and node2 by updating two positions in the matrix.


#Depth-first search
def depth_first_search(self, start_node: int, action, visited: list[bool] = None) -> list[bool]:
    if visited is None:
        visited = [False] * len(self._neighbours)
    action(start_node)
    visited[start_node] = True
    for edge in self._neighbours[start_node]:
        other_node = edge.other_node(start_node)
        if not visited[other_node]:
            self.depth_first_search(other_node, action, visited)
    return visited

#Breadth-first search
def breadth_first_search(self, start_node, action) -> list[bool]:
    visited = [False] * len(self._neighbours)
    q = Queue()
    visited[start_node] = True
    q.enqueue(start_node)
    while q.size() > 0:
        current_node = q.dequeue()
        action(current_node)
        for edge in self._neighbours[current_node]:
            other_node = edge.other_node(current_node)
            if not visited[other_node]:
                visited[other_node] = True
                q.enqueue(other_node)
    return visited

# Time Complexity Analysis for Graph Traversal Functions:

# depth_first_search(self, start_node, action, visited=None):
# O(V + E) - where V is the number of vertices (nodes) and E is the number of edges in the graph.

# breadth_first_search(self, start_node, action):
# O(V + E) - where V is the number of vertices (nodes) and E is the number of edges in the graph.

"""
Lab Assignment Code
"""

"""
lab1planes
"""

import sys
#from queue import Queue
#from stack import Stack

RUNWAY_LENGTH = 7
HANGAR_SIZE = 5
lines = sys.stdin.read().splitlines()
lines.pop() 
exit = Queue()
waiting_runway = Queue() #Waiting_runway is a queue because it is FIFO (first-in-first-out)
hangar = Stack() #Hangar is a stack because it is LIFO (last-in-first-out)

for line in lines:
    airplane, condition = line.strip().split("\t")
    if condition == "yes":
        hangar.push(airplane)
        #If the hangar is now full, clear runway and add all planes in hangar to the runway
        if hangar.size() == 5:
            while waiting_runway.size() != 0:
                exit.enqueue(waiting_runway.dequeue())
            while hangar.size() != 0:
                waiting_runway.enqueue(hangar.pop())
    elif condition == "no":
        waiting_runway.enqueue(airplane)
        #If the waiting is now full, clear it.
        if waiting_runway.size() == 7:
            while waiting_runway.size() != 0:
                exit.enqueue(waiting_runway.dequeue())

#After processing all planes, we now send planes to exit. First we send the planes from the runway, then from the hangar (because of the diagram).
while waiting_runway.size() != 0:
    exit.enqueue(waiting_runway.dequeue())
while hangar.size() != 0:
    exit.enqueue(hangar.pop())

#Print the order in which the planes exit.
while exit.size() != 0:
    print(exit.dequeue())

# Time Complexity Analysis for lab1planes.py:

# Overall Time Complexity: O(n)
# Explanation: The main loop iterates through each line in the input,
# and the operations inside the loop (enqueue, push, pop, size) are O(1)
# for the data structures used (Queue and Stack).
# The while loops after processing the lines also have O(n) complexity in total.

"""
lab2equations
"""

"""
Scanner
"""

from enum import Enum

class TokenType(Enum):
    """
    Tokens can be of three types:
    numbers (digits), identifiers (characters), and symbols (any)
    """
    NUMBER = 1
    IDENTIFIER = 2
    SYMBOL = 3


class TokenList:
    def __init__(self):
        self._type = TokenType.NUMBER
        self._value = None
        self._next = None

    def __str__(self): 
        return_value = "NUMBER" if self._type == TokenType.NUMBER else \
                        "IDENTIFIER" if self._type == TokenType.IDENTIFIER else \
                        "SYMBOl"
        if self._next is not None:
            return_value += " " + str(self._next)
        return return_value


def _match_number(text: str, position: int) -> tuple[int, int]:
    """
    Reads a number from the input
    :param text: input string
    :param position: start position of the number
    :return: (number read, first position in text after the read number)
    """
    output = 0
    while position < len(text) and "0" <= text[position] <= "9":
        output = output*10 + int(text[position])
        position += 1
    return output, position


def _match_symbol(text: str, position: int) -> tuple[str, int]:
    """
    Reads a single character as a symbol from the input
    :param text: input string
    :param position: start position of the symbol
    :return: (symbol read, first position in text after the read symbol)
    """
    return text[position], position + 1


def _match_identifier(text: str, position: int) -> tuple[str, int]:
    """
    Reads an identifier  from the input
    :param text: input string
    :param position: start position of the identifier
    :return: (identifier read, first position in text after the read identifier)
    """
    old_position = position
    while position < len(text) and text[position].isalnum():
        position += 1
    return text[old_position:position], position


def _generate_node(text: str, position: int) -> tuple[TokenList, int]:
    """
    Generates a new TokenList node.
    :param text: string to read the node information from
    :param position: start position of the information
    :return: a tuple with the generated node and the new position in the input
    """
    new_node = TokenList()
    if "0" <= text[position] <= "9":
        # A digit signals the start of a number
        new_node._type = TokenType.NUMBER
        new_node._value, position = _match_number(text, position)
    elif text[position].isalpha():
        # An alphabetic character signals an identifier
        new_node._type = TokenType.IDENTIFIER
        new_node._value, position = _match_identifier(text, position)
    else:
        # In all other cases, it is a symbol
        new_node._type = TokenType.SYMBOL
        new_node._value, position = _match_symbol(text, position)
    return new_node, position


def generate_token_list(text: str) -> TokenList:
    head = None
    tail = None
    position = 0
    while position < len(text):
        if text[position].isspace():
            position += 1
        else:
            node, position = _generate_node(text, position)
            if head is None:
                head = node
            else:
                tail._next = node
            tail = node
    return head

"""
Lab Code
"""

#from scanner import *

class TokenListPosition:
    def __init__(self, tokens: TokenList):
        self.tokens = tokens

def accept_number(position: TokenListPosition) -> bool:
    if position.tokens is not None:
        if position.tokens._type == TokenType.NUMBER:
            position.tokens = position.tokens._next
            return True
    return False

def accept_identifier(position: TokenListPosition) -> bool:
    if position.tokens is not None:
        if position.tokens._type == TokenType.IDENTIFIER:
            position.tokens = position.tokens._next
            return True
    return False

def accept_symbol(position: TokenListPosition, symbol: str) -> bool:
    if position.tokens is not None:
        if position.tokens._type == TokenType.SYMBOL:
            if position.tokens._value == symbol:
                position.tokens = position.tokens._next
                return True
    return False

def accept_factor(position: TokenListPosition) -> bool:
    return (
        accept_number(position) or
        accept_identifier(position) or
        (accept_symbol(position, "(") and 
        accept_expression(position) and 
        accept_symbol(position, ")")))

def accept_term(pos: TokenListPosition) -> bool:
    encountered_number = accept_number(pos)

    encountered_identifier = accept_identifier(pos)

    if not (encountered_number or encountered_identifier):
        return False
    elif encountered_number and not encountered_identifier:
        return True
    
    encountered_carrot = accept_symbol(pos, "^")
    if encountered_carrot:
        if not accept_number(pos):
            return False
    return True

def accept_expression(pos: TokenListPosition) -> bool:
    # Optional '-' at the beginning
    if accept_symbol(pos, "-"):
        pass

    # Must have at least one term
    if not accept_term(pos):
        return False

    # Zero or more occurrences of '+' or '-' followed by a term
    while accept_symbol(pos, "+") or accept_symbol(pos, "-"):
        if not accept_term(pos):
            return False

    return True


def recognize_equation(tokenlist: TokenList) -> bool:
    """
    Determines whether a token list represents a valid equation.
    
    :param tokenlist: input token list
    :return: True if the token list represents a valid equation, otherwise False.
    """
    pos = TokenListPosition(tokenlist)
    
    # Check for the first expression
    if not accept_expression(pos):
        return False
    
    # Check for the '=' symbol
    if not accept_symbol(pos, "="):
        return False
    
    # Check for the second expression after the '=' symbol
    if not accept_expression(pos):
        return False
    
    if not pos.tokens is None:
        return False
    
    return True


def get_degree(tokenlist: TokenList) -> int:
    """
    Determines the highest exponent in a token list.
    For linear terms, the exponentiation symbol is optional, and the exponent is considered 1.

    :param tokenlist: input token list
    :return: the highest exponent in the token list, or 0 if no exponent is found
    """
    current_token = tokenlist
    max_exponent = 0  # Default to 0 if no exponent is found

    while current_token is not None:
        if current_token._type == TokenType.SYMBOL and current_token._value == "^":
            # Check if the next token is a number (exponent)
            next_token = current_token._next
            if next_token is not None and next_token._type == TokenType.NUMBER:
                max_exponent = max(max_exponent, int(next_token._value))
        elif current_token._type == TokenType.IDENTIFIER:
            # For identifiers (e.g., x), assume an exponent of 1 if no ^ is found
            if current_token._next is None or current_token._next._type != TokenType.SYMBOL or current_token._next._value != "^":
                max_exponent = max(max_exponent, 1)
        current_token = current_token._next

    return max_exponent


def is_single_variable_equation(tokenlist: TokenList) -> bool:
    """
    Determines whether a token list contains exactly one distinct identifier.

    :param tokenlist: input token list
    :return: True iff the token list contains exactly one distinct identifier.
    """
    current_token = tokenlist
    identifiers = set()  # Set to store distinct identifiers

    while current_token is not None:
        if current_token._type == TokenType.IDENTIFIER:
            identifiers.add(current_token._value)
        current_token = current_token._next

    return len(identifiers) == 1

Time Complexity Analysis Summary:

Scanner:
    _match_number: O(k) (k = digits in number)
    _match_symbol: O(1)
    _match_identifier: O(k) (k = chars in identifier)
    generate_token_list: O(n) (n = input text length)

Parser:
    accept_term, accept_number, accept_identifier, accept_symbol: O(1)
    accept_expression: O(n) (n = tokens in expression)
    recognize_equation: O(n) (n = tokens in equation)
    get_degree: O(n) (n = tokens in equation)
    is_single_variable_equation: O(n) (n = tokens in equation)

Overall: O(n) where n is the length of the input string (due to parsing).


"""
lab3spellchecker: efficient solution
"""

class TrieNode:
    def __init__(self): #Using definition given in question
        self._children: dict[str, TrieNode] = {} 
        self.is_end_of_word = False #Keeping track of end of trie branch

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def add(self, word):
        current_node = self.root
        for char in word:
            if char not in current_node._children: #Checking if character already exists as a node
                current_node._children[char] = TrieNode() #If not, create
            current_node = current_node._children[char]
        current_node.is_end_of_word = True
    
    def search_in_trie(self, p): #Using the pseudocode from Prof. de Weerd's slides 
        t = self.root
        for x in p:
            if x not in t._children:
                return False
            t = t._children[x]
        return t.is_end_of_word

def main():
    trie = Trie() #Initiaize trie
    allowed_words = [] #Accumulate dictionary of words
    
    # Read allowed words
    while True:
        try:
            dict_word = input().strip().lower() #Case-insensitive and striping of whitespace
        except EOFError:
            break
        if dict_word == "!":
            break
        allowed_words.append(dict_word)

    for term in allowed_words: #Add each term to the trie
        trie.add(term)

    total_words = []
    separators = set("0123456789.,'/-\":;?!() ") #More efficient than list (which was used earlier)

    # Read text lines
    while True:
        try:
            line = input().strip().lower()
        except EOFError: #Handling issue with Themis
            break
        if not line:
            break
        
        word = "" #Extract the words from each line
        for letter in line:
            if letter not in separators: #Skip the separators
                word += letter
            else:
                if word:  #Avoid empty strings
                    total_words.append(word)  
                word = ""
        
        if word:  
            total_words.append(word)  #Append last word if it exists

    unknown_words = []
    for word in total_words:
        if not trie.search_in_trie(word):  # If the word is not in the trie (hence unknown)
            unknown_words.append(word)  # Add it to the list of unknown words

    for word in unknown_words:
        print(word) #Output all unknwon words
    print(f"There are {len(unknown_words)} unknown words.")

if __name__ == "__main__": #For testing of Trie()
    main()

Time Complexity Analysis:

TrieNode Class:
    __init__: O(1) - Initializes a new Trie node with an empty dictionary.

Trie Class:
    __init__: O(1) - Initializes the Trie with a root node.
    add(word): O(m) - where m is the length of the word.
    search_in_trie(word): O(m) - where m is the length of the word.

Main Program:
    Reading allowed words: O(n) - where n is the number of allowed words.
    Adding words to Trie: O(N * m) - where N is the number of allowed words,
       and m is the average length of the allowed words.
    Reading text lines: O(L) - where L is the total length of all input lines.
    Extracting total words from text lines: O(L)
    Searching for unknown words: O(T * k) - where T is the number of total words
       and k is the average length of total words.
    Outputting unknown words: O(U) - where U is the number of unknown words.

Overall: O(N*m + L + T*k)
    N: number of allowed words.
    m: average length of allowed words.
    L: total length of input lines.
    T: number of total words in input.
    k: average length of total words.

Summary:
    The trie operations (add and search) are O(m) where m is the
    length of the word. The main program complexity is dominated by
    reading the input and processing the words.  This results in a final time
    complexity of O(N*m + L + T*k).


"""
lab4expressiontrees
"""
"""
File:   expTree_test.py
Author: Vikranth Moparthy (v.moparthy@student.rug.nl)
Description:
   A program that recognises and returns the value of a numerical infix expression. If the expression is non-numeric,
it provides the simplified version of the expression and its derivative with respect to x.
"""

class Token:
    def __init__(self, token_type: TokenType, value):
        self.type = token_type
        self.value = value

def is_operator(char: str) -> bool:
    return char in "+-*/"

def precedence(op: str) -> int: #For building tree
    if op in ('+', '-'):
        return 1
    if op in ('*', '/'): #Multiplication and division have higher priority
        return 2
    return 0

def tokenize(text: str) -> list[Token]:
    if text is None:
        return None
    tokens = []
    pos = 0
    while pos < len(text):
        while pos < len(text) and text[pos].isspace():
            pos += 1
        if pos >= len(text):
            break
        if text[pos].isdigit():
            value, pos = _match_number(text, pos)
            tokens.append(Token(TokenType.NUMBER, value))
        elif text[pos].isalpha():
            identifier, pos = _match_identifier(text, pos)
            tokens.append(Token(TokenType.IDENTIFIER, identifier))
        else:
            symbol, pos = _match_symbol(text, pos)
            tokens.append(Token(TokenType.SYMBOL, symbol))
    return tokens

def build_tree(tokens: list[Token]) -> TreeNode: #Builds tree from tokens in infix order
    values = []  # Stack for operands (list representation)
    operators = []  # Stack for operators

    def apply_operator(): #Pops operands and operator, builds subtree, pushes result. With help from: https://shorturl.at/P4f8X
        if len(values) < 2 or not operators:
            return
        right = values.pop()
        left = values.pop()
        op = operators.pop()
        node = TreeNode(Token(TokenType.SYMBOL, op.value))
        node._left = left
        node._right = right
        values.append(node)

    if not tokens or tokens[0].type == TokenType.SYMBOL and tokens[0].value not in "(":  # Reject if the expression starts with an operator
        return None

    previous_token = None

    for token in tokens:
        if token.type == TokenType.NUMBER or token.type == TokenType.IDENTIFIER:
            if previous_token and previous_token.type in [TokenType.NUMBER, TokenType.IDENTIFIER]:  # Two consecutive operands are not allowed
                return None  
            values.append(TreeNode(token))

        elif token.type == TokenType.SYMBOL:
            if token.value == "(":  # If the token is an opening parenthesis
                operators.append(token)
            elif token.value == ")":  # If the token is a closing parenthesis
                while operators and operators[-1].value != "(":  
                    apply_operator()
                if not operators:
                    return None  # Unbalanced parentheses
                operators.pop()  # Remove '('
            elif token.value in "+-*/":  # Only allow +, -, *, /
                if previous_token is None or previous_token.type == TokenType.SYMBOL and previous_token.value != ")":
                    return None  # Two consecutive operators or operator at start
                while (operators and operators[-1].value != "(" and
                       precedence(operators[-1].value) >= precedence(token.value)):  # Apply operators with higher or equal precedence before adding the current operator. Use of precedence with help from: https://shorturl.at/P4f8X
                    apply_operator()
                operators.append(token)  # Add the current operator to the stack
            else:
                return None  # Reject any operator other than +, -, *, /

        previous_token = token

    # Check if the last token is an operator, which was an edge case
    if tokens and tokens[-1].type == TokenType.SYMBOL and tokens[-1].value not in ")":
        return None  # Incomplete expression (ends with an operator)

    while operators:
        if operators[-1].value in "()":  # Unbalanced parentheses
            return None  
        apply_operator()

    if values:
        if len(values) > 1:  # If there is more than one element in values at the end, expression is incomplete
            return None
        return values[0]
    else:
        return None


def generate_expression_tree(text: str) -> TreeNode | None:

    tokens = tokenize(text)
    return build_tree(tokens)

def evaluate_expression_tree(tree: TreeNode) -> float: #Recursively evaluates an expression tree
    if tree is None:
        return None

    if tree._item.type == TokenType.NUMBER:
        return tree._item.value

    left_operand = evaluate_expression_tree(tree._left)
    right_operand = evaluate_expression_tree(tree._right)

    if left_operand is None or right_operand is None:
        return None  # If either operand is None, return None
    
    if tree._item:
        match tree._item.value:
            case '*':
                return left_operand * right_operand
            case '/':
                if right_operand == 0:
                    return None
                return left_operand / right_operand
            case '-':
                return left_operand - right_operand
            case '+':
                return left_operand + right_operand
    else:
        return None

def simplify(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None

    tree._left = simplify(tree._left)   #Recursively simplify left and right subtrees
    tree._right = simplify(tree._right)

    if tree._item.type != TokenType.SYMBOL or not (tree._left and tree._right): # Only simplify if the node is an operator and has both left and right children
        return tree

    op = tree._item.value
    left = tree._left._item
    right = tree._right._item

    if op == "+":
        if left.type == TokenType.NUMBER and left.value == 0:
            return tree._right #0 + E
        if right.type == TokenType.NUMBER and right.value == 0: #E + 0
            return tree._left

    elif op == "-":
        if right.type == TokenType.NUMBER and right.value == 0: #E - 0
            return tree._left

    elif op == "*":
        if left.type == TokenType.NUMBER and left.value == 0 or right.type == TokenType.NUMBER and right.value == 0:
            return TreeNode(Token(TokenType.NUMBER, 0)) #E * 0 or 0 * E
        if left.type == TokenType.NUMBER and left.value == 1: #1 * E
            return tree._right
        if right.type == TokenType.NUMBER and right.value == 1: #E * 1
            return tree._left

    elif op == "/":
        if right.type == TokenType.NUMBER and right.value == 1:
            return tree._left #E / 1
    return tree

def differentiate(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None
    
    if tree._item.type == TokenType.NUMBER:
        return TreeNode(Token(TokenType.NUMBER, 0)) #The derivative of a constant is 0
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value == "x":
        return TreeNode(Token(TokenType.NUMBER, 1)) #The derivative of the variable x is 1
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value != "x": #If we encounter a variable that is not x, derivative of variable with respect to x is 0.
                return TreeNode(Token(TokenType.NUMBER, 0))
    
    operator = tree._item.value #Root node should be operator
    left, right = tree._left, tree._right #Store the children

    left_derivative = differentiate(left) #Recursively define the derivatives of the children
    right_derivative = differentiate(right)

    if operator == "+":
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_derivative, right_derivative) #Derivative of additions is the addition of derivatives
    
    if operator == "-":
        return TreeNode(Token(TokenType.SYMBOL, "-"), left_derivative, right_derivative) #Derivative of subtractions is the subtraction of derivatives
        
    if operator == "*":
        left_term = TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right) #Define u'v
        right_term = TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative) #Define uv'
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_term, right_term) #Product rule states derivative is sum of u'v and uv'

    if operator == "/":
        numerator = TreeNode(Token(TokenType.SYMBOL, "-"), #Subtract u'v - uv'
                            TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right), #Define u'v
                            TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative)) #Define uv'
        denominator = TreeNode(Token(TokenType.SYMBOL, "*"), right, right) #Define v^2
        return TreeNode(Token(TokenType.SYMBOL, "/"), numerator, denominator) #Finally, derivative would be numerator / denominator
    
    return tree

def is_numerical_expression_tree(tree: TreeNode) -> bool:
    if tree is None:
        return False
    if tree._item.type == TokenType.IDENTIFIER:

        return False
    if tree._item.type == TokenType.NUMBER:
        return True
    return is_numerical_expression_tree(tree._left) and is_numerical_expression_tree(tree._right)


def infix_expression_tree(tree: TreeNode) -> str:
    if tree is None:
        return "!"
    if tree._item.type == TokenType.SYMBOL:
        return f"({infix_expression_tree(tree._left)} {tree._item.value} {infix_expression_tree(tree._right)})"
    return str(tree._item.value)


def main(): #The input code is mostly the same as Prof. de Weerd's, however it is adapted slightly to meet Themis' requirements.
    expression = input("give an expression: ")
    while expression == "" or expression[0] != "!":
        tokentree = generate_expression_tree(expression)
        if tokentree is None:
            print("this is not an infix expression")
        else:
            print("expression:", end=" ")
            print(infix_expression_tree(tokentree))
            if is_numerical_expression_tree(tokentree):
                if evaluate_expression_tree(tokentree) is not None:
                    print("the value of this expression is:", end=" ")
                    print(evaluate_expression_tree(tokentree))
                else:
                    print("this is not a numerical infix expression")
                    print("simplified:", infix_expression_tree(simplify(tokentree)))
                    print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
            else:
                print("this is not a numerical infix expression")
                print("simplified:", infix_expression_tree(simplify(tokentree)))
                print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
        expression = input("\ngive an expression: ")
    print("good bye")

main()

"""
lab4expressiontrees
"""
"""
File:   expTree_test.py
Author: Vikranth Moparthy (v.moparthy@student.rug.nl)
Description:
   A program that recognises and returns the value of a numerical infix expression. If the expression is non-numeric,
it provides the simplified version of the expression and its derivative with respect to x.
"""

class Token:
    def __init__(self, token_type: TokenType, value):
        self.type = token_type
        self.value = value

def is_operator(char: str) -> bool:
    return char in "+-*/"

def precedence(op: str) -> int: #For building tree
    if op in ('+', '-'):
        return 1
    if op in ('*', '/'): #Multiplication and division have higher priority
        return 2
    return 0

def tokenize(text: str) -> list[Token]:
    if text is None:
        return None
    tokens = []
    pos = 0
    while pos < len(text):
        while pos < len(text) and text[pos].isspace():
            pos += 1
        if pos >= len(text):
            break
        if text[pos].isdigit():
            value, pos = _match_number(text, pos)
            tokens.append(Token(TokenType.NUMBER, value))
        elif text[pos].isalpha():
            identifier, pos = _match_identifier(text, pos)
            tokens.append(Token(TokenType.IDENTIFIER, identifier))
        else:
            symbol, pos = _match_symbol(text, pos)
            tokens.append(Token(TokenType.SYMBOL, symbol))
    return tokens

def build_tree(tokens: list[Token]) -> TreeNode: #Builds tree from tokens in infix order
    values = []  # Stack for operands (list representation)
    operators = []  # Stack for operators

    def apply_operator(): #Pops operands and operator, builds subtree, pushes result. With help from: https://shorturl.at/P4f8X
        if len(values) < 2 or not operators:
            return
        right = values.pop()
        left = values.pop()
        op = operators.pop()
        node = TreeNode(Token(TokenType.SYMBOL, op.value))
        node._left = left
        node._right = right
        values.append(node)

    if not tokens or tokens[0].type == TokenType.SYMBOL and tokens[0].value not in "(":  # Reject if the expression starts with an operator
        return None

    previous_token = None

    for token in tokens:
        if token.type == TokenType.NUMBER or token.type == TokenType.IDENTIFIER:
            if previous_token and previous_token.type in [TokenType.NUMBER, TokenType.IDENTIFIER]:  # Two consecutive operands are not allowed
                return None  
            values.append(TreeNode(token))

        elif token.type == TokenType.SYMBOL:
            if token.value == "(":  # If the token is an opening parenthesis
                operators.append(token)
            elif token.value == ")":  # If the token is a closing parenthesis
                while operators and operators[-1].value != "(":  
                    apply_operator()
                if not operators:
                    return None  # Unbalanced parentheses
                operators.pop()  # Remove '('
            elif token.value in "+-*/":  # Only allow +, -, *, /
                if previous_token is None or previous_token.type == TokenType.SYMBOL and previous_token.value != ")":
                    return None  # Two consecutive operators or operator at start
                while (operators and operators[-1].value != "(" and
                       precedence(operators[-1].value) >= precedence(token.value)):  # Apply operators with higher or equal precedence before adding the current operator. Use of precedence with help from: https://shorturl.at/P4f8X
                    apply_operator()
                operators.append(token)  # Add the current operator to the stack
            else:
                return None  # Reject any operator other than +, -, *, /

        previous_token = token

    # Check if the last token is an operator, which was an edge case
    if tokens and tokens[-1].type == TokenType.SYMBOL and tokens[-1].value not in ")":
        return None  # Incomplete expression (ends with an operator)

    while operators:
        if operators[-1].value in "()":  # Unbalanced parentheses
            return None  
        apply_operator()

    if values:
        if len(values) > 1:  # If there is more than one element in values at the end, expression is incomplete
            return None
        return values[0]
    else:
        return None


def generate_expression_tree(text: str) -> TreeNode | None:

    tokens = tokenize(text)
    return build_tree(tokens)

def evaluate_expression_tree(tree: TreeNode) -> float: #Recursively evaluates an expression tree
    if tree is None:
        return None

    if tree._item.type == TokenType.NUMBER:
        return tree._item.value

    left_operand = evaluate_expression_tree(tree._left)
    right_operand = evaluate_expression_tree(tree._right)

    if left_operand is None or right_operand is None:
        return None  # If either operand is None, return None
    
    if tree._item:
        match tree._item.value:
            case '*':
                return left_operand * right_operand
            case '/':
                if right_operand == 0:
                    return None
                return left_operand / right_operand
            case '-':
                return left_operand - right_operand
            case '+':
                return left_operand + right_operand
    else:
        return None

def simplify(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None

    tree._left = simplify(tree._left)   #Recursively simplify left and right subtrees
    tree._right = simplify(tree._right)

    if tree._item.type != TokenType.SYMBOL or not (tree._left and tree._right): # Only simplify if the node is an operator and has both left and right children
        return tree

    op = tree._item.value
    left = tree._left._item
    right = tree._right._item

    if op == "+":
        if left.type == TokenType.NUMBER and left.value == 0:
            return tree._right #0 + E
        if right.type == TokenType.NUMBER and right.value == 0: #E + 0
            return tree._left

    elif op == "-":
        if right.type == TokenType.NUMBER and right.value == 0: #E - 0
            return tree._left

    elif op == "*":
        if left.type == TokenType.NUMBER and left.value == 0 or right.type == TokenType.NUMBER and right.value == 0:
            return TreeNode(Token(TokenType.NUMBER, 0)) #E * 0 or 0 * E
        if left.type == TokenType.NUMBER and left.value == 1: #1 * E
            return tree._right
        if right.type == TokenType.NUMBER and right.value == 1: #E * 1
            return tree._left

    elif op == "/":
        if right.type == TokenType.NUMBER and right.value == 1:
            return tree._left #E / 1
    return tree

def differentiate(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None
    
    if tree._item.type == TokenType.NUMBER:
        return TreeNode(Token(TokenType.NUMBER, 0)) #The derivative of a constant is 0
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value == "x":
        return TreeNode(Token(TokenType.NUMBER, 1)) #The derivative of the variable x is 1
    if tree._item.type == TokenType.IDENTIFIER and tree._item.value != "x": #If we encounter a variable that is not x, derivative of variable with respect to x is 0.
                return TreeNode(Token(TokenType.NUMBER, 0))
    
    operator = tree._item.value #Root node should be operator
    left, right = tree._left, tree._right #Store the children

    left_derivative = differentiate(left) #Recursively define the derivatives of the children
    right_derivative = differentiate(right)

    if operator == "+":
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_derivative, right_derivative) #Derivative of additions is the addition of derivatives
    
    if operator == "-":
        return TreeNode(Token(TokenType.SYMBOL, "-"), left_derivative, right_derivative) #Derivative of subtractions is the subtraction of derivatives
        
    if operator == "*":
        left_term = TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right) #Define u'v
        right_term = TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative) #Define uv'
        return TreeNode(Token(TokenType.SYMBOL, "+"), left_term, right_term) #Product rule states derivative is sum of u'v and uv'

    if operator == "/":
        numerator = TreeNode(Token(TokenType.SYMBOL, "-"), #Subtract u'v - uv'
                            TreeNode(Token(TokenType.SYMBOL, "*"), left_derivative, right), #Define u'v
                            TreeNode(Token(TokenType.SYMBOL, "*"), left, right_derivative)) #Define uv'
        denominator = TreeNode(Token(TokenType.SYMBOL, "*"), right, right) #Define v^2
        return TreeNode(Token(TokenType.SYMBOL, "/"), numerator, denominator) #Finally, derivative would be numerator / denominator
    
    return tree

def is_numerical_expression_tree(tree: TreeNode) -> bool:
    if tree is None:
        return False
    if tree._item.type == TokenType.IDENTIFIER:

        return False
    if tree._item.type == TokenType.NUMBER:
        return True
    return is_numerical_expression_tree(tree._left) and is_numerical_expression_tree(tree._right)


def infix_expression_tree(tree: TreeNode) -> str:
    if tree is None:
        return "!"
    if tree._item.type == TokenType.SYMBOL:
        return f"({infix_expression_tree(tree._left)} {tree._item.value} {infix_expression_tree(tree._right)})"
    return str(tree._item.value)


def main(): #The input code is mostly the same as Prof. de Weerd's, however it is adapted slightly to meet Themis' requirements.
    expression = input("give an expression: ")
    while expression == "" or expression[0] != "!":
        tokentree = generate_expression_tree(expression)
        if tokentree is None:
            print("this is not an infix expression")
        else:
            print("expression:", end=" ")
            print(infix_expression_tree(tokentree))
            if is_numerical_expression_tree(tokentree):
                if evaluate_expression_tree(tokentree) is not None:
                    print("the value of this expression is:", end=" ")
                    print(evaluate_expression_tree(tokentree))
                else:
                    print("this is not a numerical infix expression")
                    print("simplified:", infix_expression_tree(simplify(tokentree)))
                    print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
            else:
                print("this is not a numerical infix expression")
                print("simplified:", infix_expression_tree(simplify(tokentree)))
                print("derivative to x:", infix_expression_tree(simplify(differentiate(tokentree))))
        expression = input("\ngive an expression: ")
    print("good bye")

main()
"""
lab5trainsinthestorm
"""

"""
File:   trainsinthestorms.py
Authors: Vikranth Moparthy (v.moparthy@student.rug.nl), Prof. Harmen de Weerd (harmen.de.weerd@rug.nl)

Description:
    A program that finds the fastest train connections between a pair of cities in the Netherlands given a network of connections of many cities and travel times between them. 
    Also factors in possible disruptions.
"""
#from ADS import GraphEdge, UndirectedGraph, Heap

def dijkstra(G: UndirectedGraph, start: int) -> tuple[dict, dict]:
    distances = {node: float('inf') for node in range(len(G._neighbours))}  #Initally all distances to all nodes are infinity 
    predecessors = {node: None for node in range(len(G._neighbours))} #Keeping track of path
    distances[start] = 0 #Node distance to itself is 0

    heap = Heap() #Implementing heap for inverted priority queue
    heap.enqueue((0, start))

    while heap.size > 0: 
        current_dist, u = heap.remove_min() #Node with minimal distance from 
        
        # Skip processed nodes with outdated distances
        if current_dist > distances[u]:
            continue
            
        # Explore neighbors
        for edge in G._neighbours[u]:
            v = edge.other_node(u)
            weight = edge.get_weight()
                # If a shorter path to v is found
            new_dist = distances[u] + weight

            if new_dist < distances[v]:
                distances[v] = new_dist
                predecessors[v] = u
                heap.enqueue((new_dist, v)) #Add v to heap for further exploration

    paths = {} #Backtracking paths
    for node in range(len(G._neighbours)):
        if distances[node] == float('inf'): #In case a path does not exist
            paths[node] = None
            continue
            
        path = []
        current = node
        while current is not None:
            path.append(current)
            current = predecessors[current]
        paths[node] = path[::-1]  # Reverse to get start->end order

    return distances, paths

def main():
    G = UndirectedGraph(12)
    nodes = {
        "Den Helder": 0, "Amsterdam": 1, "Den Haag": 2, "Utrecht": 3, "Eindhoven": 4, 
        "Maastricht": 5, "Nijmegen": 6, "Zwolle": 7, "Enschede": 8, "Meppel": 9, 
        "Leeuwarden": 10, "Groningen": 11
    } #Map each city to a number

     #Add all the connections as given in the question
    G.add_edge(nodes["Amsterdam"], nodes["Den Haag"], 46)
    G.add_edge(nodes["Amsterdam"], nodes["Den Helder"], 77)
    G.add_edge(nodes["Amsterdam"], nodes["Utrecht"], 26)
    G.add_edge(nodes["Den Haag"], nodes["Eindhoven"], 89)
    G.add_edge(nodes["Eindhoven"], nodes["Maastricht"], 63)
    G.add_edge(nodes["Eindhoven"], nodes["Nijmegen"], 55)
    G.add_edge(nodes["Eindhoven"], nodes["Utrecht"], 47)
    G.add_edge(nodes["Enschede"], nodes["Zwolle"], 50)
    G.add_edge(nodes["Groningen"], nodes["Leeuwarden"], 34)
    G.add_edge(nodes["Groningen"], nodes["Meppel"], 49)
    G.add_edge(nodes["Leeuwarden"], nodes["Meppel"], 40)
    G.add_edge(nodes["Maastricht"], nodes["Nijmegen"], 111)
    G.add_edge(nodes["Meppel"], nodes["Zwolle"], 15)
    G.add_edge(nodes["Nijmegen"], nodes["Zwolle"], 77)
    G.add_edge(nodes["Utrecht"], nodes["Zwolle"], 51)

    input_lines = [] #First take all input
    while True:
        line = input().strip()
        if line == "!":
            break
        input_lines.append(line)
    
    # Process disruptions
    n = int(input_lines[0])
    idx = 1
    for _ in range(n):
        city1 = input_lines[idx]
        city2 = input_lines[idx+1]
        G.remove_edge(nodes[city1], nodes[city2]) #Remove edges where disruptions occur, because there exists no connection between them
        idx += 2
    
    # Process queries
    while idx < len(input_lines):
        start = input_lines[idx]
        end = input_lines[idx+1]
        idx += 2
        
        start_node = nodes.get(start)
        end_node = nodes.get(end)
        
        if start_node is None or end_node is None:
            print("UNREACHABLE") #Incomplete or erroneous input
            continue
        
        distances, paths = dijkstra(G, start_node)
        
        if distances[end_node] == float("inf"): #Case where distance is infinity
            print("UNREACHABLE")
        else:
            path = paths[end_node] #Extract the path to the required destination node
            for node in path:
                city = next(k for k, v in nodes.items() if v == node) #How to get key given value in dictionary. Source: https://shorturl.at/p5h1S
                print(city)
            print(distances[end_node])

main()

# Time Complexity Analysis:
# - V: Number of vertices (cities in the graph).
# - E: Number of edges (connections between cities).
# - Initialization (distances, predecessors): O(V)
# - Enqueue operation (heap insertion): O(V log V)
# - Remove_min (linear search + downheap): O(V^2), as it's called once per vertex and costs O(V) per call.
# - Edge relaxation (updating distances and enqueueing neighbors): O(E log V)
# Overall: O(V^2 + E log V) due to inefficient remove_min.
"""
Tutorial Code / Additional Code

"""

#2.3: Stack from one or more queues

class StackUsingQueue:
    def __init__(self):
        self.queue1 = Queue()
        self.queue2 = Queue()

    def push(self, item):
        self.queue1.enqueue(item)

    def pop(self):
        if self.queue1.size() == 0:
            print("Stack is empty!")
            return None

        # Move all elements from queue1 to queue2, except the last one
        while self.queue1.size() > 1:
            self.queue2.enqueue(self.queue1.dequeue())
        
        # The last element in queue1 is the one to pop
        item = self.queue1.dequeue()

        # Swap queues
        self.queue1, self.queue2 = self.queue2, self.queue1

        return item
    
#2.4: Checking if parenthetical expression in balanced

def is_balanced(s):
    stack = Stack()
    for i in s:
        if i == "(" or i == "[":
            stack.push(i)
        elif i == "]":
            if stack.size() == 0 or stack.pop() != "[":
                print("unbalanced")
                return
        elif i == ")":
            if stack.size() == 0 or stack.pop() != "(":
                print("unbalanced")
                return
    if stack.size() != 0:
        print("unbalanced")
    else:
        print("balanced")

#2.6: Pop method in Queue()

def pop(self):
    """
    Retrieve and remove the value that was added last
    :return: the item that was added last to the queue
    """
    if self.size() == 0:
        print("Queue empty!")
        return None
    
    val = self._q[self._back - 1]
    self._back = (self._back - 1) % len(self._q)
    return val

#2.7: Pop in stack removes max element

def pop(self):
    """
    Removes and returns the item on top of the stack
    :return: item on top of the stack
    """
    max_ = max(self._stack)
    self._stack.remove(max_)
    return max_

#2.8: Copy a stack

def copy_stack_recursively(stack):
    """
    Function to copy a stack recursively.
    """
    # Base case: If the stack is empty, return an empty list (representing an empty stack)
    if not stack:
        return []

    # Step 1: Pop the top element from the stack
    top_element = stack.pop()

    # Step 2: Copy the rest of the stack recursively
    copied_stack = copy_stack_recursively(stack)

    # Step 3: Push the popped element to the copied stack to maintain order
    copied_stack.append(top_element)

    # Step 4: Push the element back to the original stack to preserve its state
    stack.append(top_element)

    return copied_stack

#2.11: LinkedList method to find whether a particular value exists. (Iterative solution)

def find(self, value):
    while self._next is not None and self._next._item != value:
        self = self._next
    if self._next is None:
        return False
    else:
        return True

#2.12: LinkedList method to remove all nodes from a list with a given value
def remove_all(self, value):
    if self._next is None:
        return
    if self._next._item == value:
        self.remove_first_item()
        self.remove_all(value)
    else:
        self._next.remove_all(value)

#2.13: LinkedList method to remove a node at a given position from a list
def remove_at_index(self, pos):
    if pos > self.size():
        return self._list_too_short_error()
    if pos == 0:
        self.remove_first_item()
    if self._next is not None:
        return self._next.remove_at_index(pos - 1)
    
#2.15 LinkedList method to remove last occurence of a given value
def remove_last_occurrence(self, value) -> None:

    prev_last = None  # Track predecessor of the last occurrence
    prev = self       # Current predecessor node during traversal
    current = self._next  # Current node being checked
    
    # Traverse the entire list
    while current is not None:
        if current._item == value:
            prev_last = prev  # Update last found position
        prev = current
        current = current._next
    
    # Remove the node if found
    if prev_last is not None:
        prev_last._next = prev_last._next._next
    else:
        self._value_not_found_error()

#2.16: LinkedList method to remove consecutive duplicate values
def remove_duplicates(self):
    if self._next is None:
        return
    if self._next._next is not None and self._next._item == self._next._next._item:
        self._next = self._next._next  # Remove duplicate
        self.remove_duplicates()  # Continue checking
    else:
        self._next.remove_duplicates()  # Move to next node


#3.3 a) Function to copy a tree
def copy_tree(tree: TreeNode) -> TreeNode:
    if tree is None:
        return None
    return TreeNode(tree._item, copy_tree(tree._left), copy_tree(tree._right))

#3.3 b) Get height of tree
def tree_height(tree: TreeNode) -> int:
    if tree is None:
        return -1  # Return -1 so that a single-node tree has height 0
    
    left_height = tree_height(tree._left)
    right_height = tree_height(tree._right)
    
    return 1 + max(left_height, right_height)


#3.3 c) Number of nodes in tree
def node_number(tree: TreeNode) -> int:
    if tree is None:
        return 0
    return 1 + node_number(tree._left) + node_number(tree._right)

#3.3 d) Find node with max value
def find_max_node(tree: TreeNode) -> int | None:
    if not tree:
        return None
    current = tree
    while current._right is not None:
        current = current._right
    return current._item

#3.3 e) Highest position that contains a rode

def is_search_tree(root: TreeNode) -> bool:
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node:
            return True
        if not (low < node._item < high):
            return False
        return (validate(node._left, low, node._item) and 
                validate(node._right, node._item, high))
    return validate(root)

#3.4: Finds node with a given position, n

def find_node(tree: TreeNode, pos: int) -> TreeNode:
    if tree is None:
        return None
    
    if pos == 1:
        return tree
    
    parent_pos = pos // 2

    if pos % 2 == 0:
        return find_node(tree._left, parent_pos)
    else:
        return find_node(tree._right, parent_pos)
    
#3.7 Tree to list
def tree_to_list(tree: TreeNode, index=1, result=None) -> list:
    if result is None:
        result = []
    
    # Ensure the list is large enough for the current index
    while len(result) < index:
        result.append(None)
    
    result[index - 1] = tree._item  # 1-based index adjustment

    if tree._left:
        tree_to_list(tree._left, index * 2, result)  # Left child at index * 2
    if tree._right:
        tree_to_list(tree._right, index * 2 + 1, result)  # Right child at index * 2 + 1

    return result

#3.8 a) Inorder Successor
def inorder_successor(node: TreeNode) -> TreeNode:
    if node._right is not None:
        w = node._right
        while w._left is not None:
            w = w._left
        return w
    return None

def remove_from_search_tree(tree: TreeNode, value: int) -> TreeNode:
    # Step 1: Search for the node to remove
    node = tree
    parent = None
    
    # Find the node
    while node is not None and node._item != value:
        parent = node
        if value < node._item:
            node = node._left
        else:
            node = node._right

    if node is None:
        return tree  # Value not found, return tree as is

    # Step 2: Node found, remove the node based on number of children
    # Case 1: Node has no children (leaf node)
    if node._left is None and node._right is None:
        if parent is None:
            return None  # If root node is to be deleted, return None
        if parent._left == node:
            parent._left = None
        else:
            parent._right = None
    
    # Case 2: Node has one child
    elif node._left is None or node._right is None:
        child = node._left if node._left is not None else node._right
        if parent is None:
            return child  # If root node is to be deleted, return its only child
        if parent._left == node:
            parent._left = child
        else:
            parent._right = child
    
    # Case 3: Node has two children
    else:
        # Find the inorder successor
        successor = inorder_successor(node)
        
        # Replace node's value with the successor's value
        node._item = successor._item
        
        # Now remove the successor node
        remove_from_search_tree(node._right, successor._item)  # Successor is always in the right subtree

    return tree

#Time complextity: Worst case: O(H), Balanced tree: O(log H), where H is the height of the tree

#3.10: Function to upheap (already there)

#3.11: Function to downheap (already there)


"""
Additional Useful Functions
"""
def dijkstra_with_paths(G: UndirectedGraph, start: int) -> tuple[dict, dict]: #Dijkstra's algorithm with shortest path
    distances = {node: float('inf') for node in range(len(G._neighbours))}
    predecessors = {node: None for node in range(len(G._neighbours))}
    distances[start] = 0

    heap = Heap()
    heap.enqueue((0, start))

    while heap.size > 0:
        current_dist, u = heap.remove_min()

        if current_dist > distances[u]:
            continue

        for edge in G._neighbours[u]:
            v = edge.other_node(u)
            weight = edge.get_weight()
            new_dist = distances[u] + weight

            if new_dist < distances[v]:
                distances[v] = new_dist
                predecessors[v] = u
                heap.enqueue((new_dist, v))

    paths = {}
    for node in range(len(G._neighbours)):
        if distances[node] == float('inf'):
            paths[node] = None
        else:
            path = []
            current = node
            while current is not None:
                path.append(current)
                current = predecessors[current]
            paths[node] = path[::-1]

    return distances, paths

"""
The graph uses an adjacency list  total neighbor checks = O(E)
The custom heaps remove_min() scans the whole heap  O(N) per call
The heap can grow up to O(E) elements (one per edge)
Up to O(E) calls to enqueue  O(E log E) total
Up to O(E) calls to remove_min()  O(E) total
Reconstructing paths takes O(V) in worst case
Total time complexity: O(E + V)
"""

# Tutorial / Additional Code: Time Complexity Summary:

# StackUsingQueue:
# push: O(1) - Simple enqueue operation.
# pop: O(n) - Transfers all elements except the last one to another queue.

# is_balanced (Balanced Parentheses):
# O(n) - Each character is processed once with stack operations.

# Queue pop method:
# pop: O(1) - Direct index manipulation.

# Stack pop (removes max element):
# pop: O(n) - Scans all elements to find and remove the maximum.

# Copy stack recursively:
# O(n^2) - Repeated stack traversal during recursion.

# LinkedList methods:
# find: O(n) - Sequential traversal to find a value.
# remove_all: O(n) - Recursively removes all nodes with a given value.
# remove_at_index: O(n) - Traverses nodes up to the specified index.
# remove_last_occurrence: O(n) - Traverses all nodes to find and remove the last occurrence.
# remove_duplicates: O(n) - Recursively checks consecutive nodes for duplicates.

# Tree functions:
# copy_tree: O(n) - Visits all nodes to copy them.
# tree_height: O(n) - Calculates height by visiting all nodes once.
# node_number: O(n) - Counts all nodes recursively.
# find_max_node: O(h) - Traverses along the rightmost path (height h).
# is_search_tree: O(n) - Validates each node recursively using range constraints.
# find_node: O(h) - Traverses down to a specific position (height h).
# tree_to_list: O(n) - Visits all nodes to convert them into a list representation.
# inorder_successor: O(h) - Traverses leftmost nodes in a subtree (height h).
# remove_from_search_tree:
#   Worst case: O(h), where h is the height of the tree.
#   Balanced tree: O(log n), where n is the number of nodes.

# Dijkstra's Algorithm:
# dijkstra_with_paths:
# Total time complexity: O(E + V), where E is the number of edges and V is the number of vertices.
